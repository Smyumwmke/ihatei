软件开发的技术基础-软件工程与计算-(卷二) PDF下载 络斌主编 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711140750
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711140750
<p>书名:软件开发的技术基础-软件工程与计算-(卷二)</p><p>作者:络斌　主编</p><p>页数:440</p><p>定价:¥55.0</p><p>出版社:机械工业出版社</p><p>出版日期:2012-12-01</p><p>ISBN:9787111407508</p><p><h2>内容简介</h2></p>[<p>
                                    
                                        
　　《高等院校软件工程专业规划教材：软件工程与计算（卷2）：软件开发的技术基础》作为国家精品课程“软件工程与计算”系列课程的第二门课程配套教材，《高等院校软件工程专业规划教材：软件工程与计算（卷2）：软件开发的技术基础》以经典软件工程方法与技术为主线，软件开发技术与程序设计知识为教学重点，培养学生简单小组级别、中小规模软件系统的软件开发能力。

　　全书主要分为六部分。**部分介绍软件工程的基本框架。第二部分介绍项目启动阶段的知识。第三部分介绍软件需求开发的基础知识，包括软件需求工程的概要、软件需求的内涵、常见的需求分析方法、软件需求文档。第四部分首先介绍软件设计的基础概念，之后沿着设计过程和设计技术两条主线，深入描述软件设计的相关知识。第五部分介绍软件构造、测试、移交与维护等软件开发的下游工程的基础知识。第六部分是对**部分的延续，通过总结性回顾，进一步加深读者对软件工程的理解。

　　《高等院校软件工程专业规划教材：软件工程与计算（卷2）：软件开发的技术基础》可作为高等院校软件工程、计算机及相关专业本科生软件工程课程的教材，也可作为从事软件开发的相关技术人员的参考书。                                    </p>]<p><h2>目录</h2></p>
前言**部分 软件工程概论第1章 软件工程基础1.1 软件1.1.1 软件独立于硬件1.1.2 软件是一种工具1.1.3 软件的核心是程序1.1.4 软件开发远比编程要复杂1.1.5 应用软件基于现实又高于现实1.2 软件工程1.2.1 定义1.2.2 软件工程是一种工程活动1.2.3 软件工程的动机1.2.4 软件工程是科学性、实践性和工艺性并重的1.2.5 软件工程追求足够好，不是*好1.2.6 软件工程的产品是基于虚拟计算机的软件方案1.2.7 软件工程的*终目的1.3 软件工程概览1.3.1 软件工程知识域1.3.2 软件开发活动1.3.3 软件工程的角色分工1.4 习题第2章 软件工程的发展2.1 软件工程的发展脉络2.2 20世纪50年代的软件工程2.3 20世纪60年代的软件工程2.4 20世纪70年代的软件工程2.5 20世纪80年代的软件工程2.6 20世纪90年代的软件工程2.7 21世纪00年代的软件工程2.8 习题第二部分 项目启动第3章 示例项目描述3.1 背景3.2 目标3.3 系统用户3.4 用户访谈要点3.5 项目实践过程第4章 项目管理基础4.1 项目和项目管理4.2 团队组织与管理4.2.1 团队的特征4.2.2 团队结构4.2.3 团队建设4.3 软件质量保障4.3.1 软件质量4.3.2 质量保障4.3.3 评审4.3.4 质量度量4.4 软件配置管理4.4.1 配置管理动机4.4.2 配置项4.4.3 基线4.4.4 配置管理活动4.4.5 变更控制4.5 项目实践4.6 习题第三部分 需求开发阶段第5章 软件需求基础5.1 引言5.2 需求工程基础5.2.1 需求工程简介5.2.2 需求工程活动5.2.3 需求获取5.2.4 需求分析5.2.5 需求规格说明5.2.6 需求验证5.2.7 需求管理5.3 需求基础5.3.1 需求5.3.2 需求的层次性5.3.3 结合层次性的需求开发5.3.4 区分需求、问题域与规格说明5.4 需求分类5.4.1 需求谱系5.4.2 软件需求的分类5.5 项目实践5.6 习题第6章 需求分析方法6.1 需求分析基础6.1.1 需求分析的原因6.1.2 需求分析模型6.2 结构化分析6.2.1 结构化分析方法6.2.2 数据流图6.2.3 实体关系图6.3 面向对象分析6.3.1 面向对象分析方法6.3.2 用例6.3.3 用例图6.3.4 用例描述6.3.5 概念类图（领域模型）6.3.6 交互图（顺序图）6.3.7 状态图6.4 使用需求分析方法细化和明确需求6.4.1 细化和明确需求内容6.4.2 建立系统级需求6.5 项目实践6.6 习题第7章 需求文档化与验证7.1 文档化的原因7.2 需求文档基础7.2.1 需求文档的交流对象7.2.2 用例文档7.2.3 软件需求规格说明文档7.3 需求文档化要点7.3.1 技术文档写作要点7.3.2 需求书写要点7.3.3 软件需求规格说明文档书写要点7.4 评审软件需求规格说明文档7.4.1 需求验证与确认7.4.2 评审需求的注意事项7.5 以需求为基础开发系统测试用例7.5.1 开发测试用例套件7.5.2 开发测试用例7.6 度量需求7.7 将需求制品纳入配置管理7.8 项目实践7.9 习题第四部分 软件设计第8章 软件设计基础8.1 软件设计思想的发展8.2 软件设计的核心思想8.3 理解软件设计8.3.1 设计与软件设计8.3.2 工程设计与艺术设计8.3.3 理性主义和经验主义8.3.4 软件设计的演化性8.3.5 软件设计的决策性8.3.6 软件设计的约束满足和多样性8.4 软件设计的分层8.5 软件设计过程的主要活动8.6 软件设计的方法和模型8.6.1 软件设计的方法8.6.2 软件设计的模型8.7 软件设计描述8.7.1 设计视图和设计图8.7.2 设计视角和设计关注8.7.3 需求和涉众8.7.4 设计理由8.7.5 设计描述的模板8.7.6 软件设计文档书写要点8.8 项目实践8.9 习题第9章 软件体系结构基础9.1 软件体系结构的发展9.2 理解软件体系结构9.2.1 定义9.2.2 区分软件体系结构的抽象与实现9.2.3 部件9.2.4 连接件9.2.5 配置9.3 体系结构风格初步9.3.1 主程序/子程序9.3.2 面向对象式9.3.3 分层9.3.4 mvc9.4 项目实践9.5 习题第10章 软件体系结构设计与构建10.1 体系结构设计过程10.1.1 分析关键需求和项目约束10.1.2 选择体系结构风格10.1.3 软件体系结构逻辑设计10.1.4 软件体系结构实现10.1.5 完善软件体系结构设计10.1.6 定义构件接口10.2 体系结构的原型构建10.2.1 包的创建10.2.2 重要文件的创建10.2.3 定义构件之间的接口10.2.4 关键需求的实现10.3 体系结构集成与测试10.3.1 集成的策略10.3.2 桩、驱动与集成测试用例10.4 软件体系结构设计文档描述10.5 体系结构评审10.6 项目实践10.7 习题第11章 人机交互设计11.1 引言11.2 人机交互设计的目标11.3 人机交互设计的人类因素11.3.1 精神模型11.3.2 差异性11.4 人机交互设计的计算机因素11.4.1 可视化设计11.4.2 常见界面类型11.5 人机交互设计的交互性11.5.1 导航11.5.2 反馈11.5.3 一些人机交互设计原则11.6 人机交互设计过程11.6.1 基本过程11.6.2 示例11.7 项目实践11.8 习题第12章 详细设计的基础12.1 详细设计概述12.1.1 详细设计出发点12.1.2 详细设计的上下文12.2 结构化设计12.2.1 结构化设计的思想12.2.2 结构化设计的过程12.3 面向对象设计12.3.1 面向对象设计的思想12.3.2 面向对象设计的过程12.3.3 通过职责建立静态模型12.3.4 通过协作建立动态模型12.4 为类间协作开发集成测试用例12.5 详细设计文档描述12.6 详细设计的评审12.7 项目实践12.8 习题第13章 详细设计中的模块化与信息隐藏13.1 模块化与信息隐藏思想13.1.1 设计质量13.1.2 模块化与信息隐藏思想的动机13.1.3 模块化与信息隐藏思想的发展13.2 模块化13.2.1 分解与模块化13.2.2 结构化设计中的耦合13.2.3 结构化设计中的内聚13.2.4 回顾：mscs系统设计中的模块化思想13.3 信息隐藏13.3.1 抽象与信息隐藏13.3.2 信息与隐藏13.3.3 模块说明13.3.4 回顾：mscs系统设计中的信息思想13.4 习题第14章 详细设计中面向对象方法下的模块化14.1 面向对象中的模块14.1.1 类14.1.2 类之间的联系14.2 访问耦合14.2.1 访问耦合的分析14.2.2 降低访问耦合的方法14.3 继承耦合14.3.1 继承耦合的分析14.3.2 降低继承耦合的方法14.4 内聚14.4.1 面向对象中的内聚14.4.2 提高内聚的方法14.5 耦合与内聚的度量14.5.1 耦合的度量14.5.2 内聚的度量14.6 项目实践14.7 习题第15章 详细设计中面向对象方法下的信息隐藏15.1 封装类的职责15.1.1 类的职责15.1.2 封装——分离接口与实现15.1.3 封装实现细节15.2 为变更而设计15.2.1 封装变更/开闭原则15.2.2 多态15.2.3 依赖倒置原则15.2.4 总结15.3 项目实践15.4 习题第16章 详细设计的设计模式16.1 设计模式基础16.2 可修改性及其基本实现机制16.3 策略模式16.3.1 典型问题16.3.2 设计分析16.3.3 解决方案16.3.4 模式实例16.4 抽象工厂模式16.4.1 典型问题16.4.2 设计分析16.4.3 解决方案16.4.4 模式实例16.5 单件模式16.5.1 典型问题16.5.2 设计分析16.5.3 解决方案16.5.4 模式实例16.6 迭代器模式16.6.1 典型问题16.6.2 设计分析16.6.3 解决方案16.6.4 模式实例16.7 项目实践16.8 习题第五部分 软件构造、测试、交付与维护第17章 软件构造17.1 概述17.1.1 软件构造的定义17.1.2 软件构造是设计的延续17.2 软件构造活动17.2.1 详细设计17.2.2 编程17.2.3 测试17.2.4 调试17.2.5 代码评审17.2.6 集成与构建17.2.7 构造管理17.3 软件构造实践方法17.3.1 重构17.3.2 测试驱动开发17.3.3 结对编程17.4 项目实践17.5 习题第18章 代码设计18.1 设计易读的代码18.1.1 格式18.1.2 命名18.1.3 注释18.2 设计易维护的代码18.2.1 小型任务18.2.2 复杂决策18.2.3 数据使用18.2.4 明确依赖关系18.3 设计可靠的代码18.3.1 契约式设计18.3.2 防御式编程18.4 使用模型辅助设计复杂代码18.4.1 决策表18.4.2 伪代码18.4.3 程序流程图18.5 为代码开发单元测试用例18.5.1 为方法开发测试用例18.5.2 使用mock object测试类方法18.5.3 为类开发测试用例18.6 代码复杂度度量18.7 问题代码18.8 项目实践18.9 习题第19章 软件测试19.1 引言19.1.1 验证与确认19.1.2 软件测试的目标19.1.3 测试用例19.1.4 桩与驱动19.1.5 缺陷、错误与失败19.2 测试层次19.2.1 测试层次的划分19.2.2 单元测试19.2.3 集成测试19.2.4 系统测试19.3 测试技术19.3.1 测试用例的选择19.3.2 随机测试19.3.3 基于规格的技术——黑盒测试方法19.3.4 基于代码的技术——白盒测试方法19.3.5 特定测试技术19.4 测试活动19.5 测试度量19.6 项目实践19.7 习题第20章 软件交付20.1 安装与部署20.1.1 安装20.1.2 部署20.2 培训与文档支持20.2.1 培训20.2.2 文档支持20.3 项目评价20.3.1 项目评价的原因20.3.2 项目评价的内容20.3.3 项目评价的方法20.3.4 注意事项20.4 项目实践20.5 习题第21章 软件维护与演化21.1 软件维护21.1.1 软件可修改性与软件维护21.1.2 软件维护的类型21.1.3 软件维护的高代价性21.1.4 开发可维护的软件21.1.5 软件维护过程与活动21.2 软件演化21.2.1 演化与维护21.2.2 软件演化定律21.2.3 软件演化生命周期模型与演化活动21.3 软件维护与演化的常见技术21.3.1 遗留软件21.3.2 逆向工程21.3.3 再工程21.4 项目实践21.5 习题第六部分 软件过程模型与职业基础第22章 软件开发过程模型22.1 软件开发的典型阶段22.1.1 软件需求工程22.1.2 软件设计22.1.3 软件构造22.1.4 软件测试22.1.5 软件交付22.1.6 软件维护22.2 软件生命周期模型22.3 软件过程模型22.4 构建-修复模型22.5 瀑布模型22.6 增量迭代模型22.7 演化模型22.8 原型模型22.9 螺旋模型22.10 rational统一过程22.11 敏捷过程22.12 习题第23章 软件工程职业基础23.1 软件工程职业23.1.1 软件行业的发展23.1.2 软件工程职业的出现23.1.3 软件工程师职业素质23.2 软件工程职业概况23.2.1 知识体系23.2.2 教育体系23.2.3 职业道德规范23.2.4 认证体系23.2.5 行业协会23.3 软件工程的行业标准23.4 习题附录a 软件需求规格说明文档模板附录b 文档注释规范附录c _软件工程道德和职业实践规范（5.2版）的八项原则附录d 连锁商店管理系统（mscs）相关文档参考文献                            
