计算机科学优选技术译丛C++函数式编程 PDF下载 [塞尔维亚]伊凡·库奇（Ivan 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711164198
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711164198
<p>书名:计算机科学优选技术译丛C++函数式编程</p><p>作者:[塞尔维亚]伊凡·库奇（Ivan </p><p>页数:262</p><p>定价:¥99.0</p><p>出版社:机械工业出版社</p><p>出版日期:2017-12-01</p><p>ISBN:9787111641988</p><p><h2>本书特色</h2></p>[<p>
《C  函数式编程》介绍了C  的面向函数式编程。面向函数式编程是继面向对象编程之后又一编程范式，解决了命令式（过程式）编程与面向对象编程中出现的问题，是一种极具潜力的编程方式，值得研究学习。主要讲解了函数对象、纯洁性（Purity）、惰性求值、range、函数式数据结构、代数类型及模式匹配、monad、模板元编程、并发系统的函数式设计，以及测试与调试等有关内容，还介绍了使用原有函数创建新函数的知识。<br/>《C  函数式编程》不仅可以作为C  程序员、编程爱好者以及软件工程师学习函数式编程的参考书，还可以作为高等院校C  编程语言课的高级教材
                                        </p>]<p><h2>内容简介</h2></p>[<p>《C++函数式编程》介绍了C++的面向函数式编程。面向函数式编程是继面向对象编程之后又一编程范式，解决了命令式（过程式）编程与面向对象编程中出现的问题，是一种极具潜力的编程方式，值得研究学习。主要讲解了函数对象、纯洁性（Purity）、惰性求值、range、函数式数据结构、代数类型及模式匹配、monad、模板元编程、并发系统的函数式设计，以及测试与调试等有关内容，还介绍了使用原有函数创建新函数的知识。《C++函数式编程》不仅可以作为C++程序员、编程爱好者以及软件工程师学习函数式编程的参考书，还可以作为高等院校C++编程语言课的不错教材扫描</p>]<p><h2>作者简介</h2></p>[<p>Ivan ?uki? 在贝尔格莱德数学系教授现代C  技术和函数式编程。他从1998 年开始使用C  。在以前和攻读博士学位时研究函数式编程，他应用函数式编程技术编写了全球数亿人使用的真实项目。Ivan是KDE 的核心开发人员，KDE 是*大的开源C  项目。</p>]<p><h2>目录</h2></p>
    目录译者序致谢前言关于本书关于作者第1 章 函数式编程简介 1.1 什么是函数式编程？ 1.1.1 与面向对象编程的关系1.1.2 命令式与声明式编程的比较 1.2 纯函数（Pure functions）1.2.1 避免可变状态1.3 以函数方式思考问题 ·1.4 函数式编程的优点 1.4.1 代码简洁易读1.4.2 并发和同步 1.4.3 持续优化1.5 C  作为函数式编程语言的进化 1.6 将会学到什么 总结 第2 章 函数式编程之旅 2.1 函数使用函数？2.2 STL 实例 2.2.1 求平均值2.2.2 折叠（Folding）2.2.3 删除字符串空白符2.2.4 基于谓词分割集合2.2.5 过滤（Filtering）和转换（Transforming）2.3 STL 算法的可组合性 2.4 编写自己的高阶函数 2.4.1 接收函数作为参数2.4.2 用循环实现 2.4.3 递归（Recursion）和尾调用优化（Tail-call optimization）2.4.4 使用折叠实现总结第3 章 函数对象 3.1 函数和函数对象3.1.1 自动推断返回值类型3.1.2 函数指针3.1.3 调用操作符重载3.1.4 创建通用函数对象3.2 lambda 和闭包（Closure） 3.2.1 lambda 语法3.2.2 lambda 详解3.2.3 在lambda 中创建任意成员变量3.2.4 通用lambda 表达式3.3 编写比lambda 更简洁的函数对象3.3.1 STL 中的操作符函数对象 3.3.2 其他库中的操作符函数对象 3.4 用std::function 包装函数对象 总结第4 章 以旧函数创建新函数 4.1 偏函数应用 4.1.1 把二元函数转换成一元函数的通用方法4.1.2 使用std::bind 绑定值到特定的函数参数4.1.3 二元函数参数的反转4.1.4 对多参数函数使用std::bind 4.1.5 使用lambda 替代std::bind4.2 柯里化（Currying）：看待函数不同的方式 4.2.1 创建柯里化函数的简单方法 4.2.2 数据库访问柯里化 4.2.3 柯里化与偏函数应用 4.3 函数组合 4.4 函数提升（复习） 4.4.1 键值对列表反转总结第5 章 纯洁性：避免可变状态5.1 可变状态带来的问题5.2 纯函数和引用透明 5.3 无副作用编程5.4 并发环境中的可变状态与不可变状态 5.5 const 的重要性5.5.1 逻辑const 与内部const5.5.2 对于临时值优化成员函数 5.5.3 const 的缺陷 总结第6 章 惰性求值 6.1 C  的惰性 6.2 惰性作为一种优化技术6.2.1 集合惰性排序6.2.2 用户接口中的列表视图 6.2.3 通过缓存函数结果修剪递归树6.2.4 动态编程作为惰性形式 6.3 通用记忆化（Generalized memoization）6.4 表达式模板与惰性字符串拼接 6.4.1 纯洁性与表达式模板总结第7 章 range 7.1 range 简介7.2 创建数据的只读视图7.2.1 range 的filter 函数 7.2.2 range 的transform 函数7.2.3 range 惰性求值 7.3 修改range 中的值7.4 定界rang 和无限range7.4.1 用定界range 优化用于输入的range 7.4.2 用哨兵创建无限range7.5 用range 统计词频 总结 第8 章 函数式数据结构 8.1 不可变链表（Immutable linked lists）8.1.1 在表头添加和删除元素8.1.2 在链表末尾添加和删除元素8.1.3 在链表中间添加和删除元素8.1.4 内存管理8.2 不可变类向量结构8.2.1 位图向量树中的元素查找8.2.2 向位图向量树追加元素 8.2.3 位图向量树的修改8.2.4 在位图向量树的末尾删除元素8.2.5 其他操作和位图向量树的整体效率总结 第9 章 代数数据类型及模式匹配9.1 代数数据类型 9.1.1 通过继承实现和类型 9.1.2 通过union 和std::variant 实现和类型9.1.3 特定状态的实现9.1.4 特殊的和类型：Optional9.1.5 和类型用于错误处理9.2 使用代数数据类型进行域建模9.2.1 原始的方法及其缺点 9.2.2 更复杂的方法：自上而下的设计9.3 使用模式匹配更好地处理代数数据类型 9.4 Mach7 的强大匹配功能 总结 第10 章 monad 10.1 仿函数并不是以前的仿函数10.1.1 处理可选值10.2 monad：更强大的仿函数10.3 基本的例子10.4 range 与monad 的嵌套使用 10.5 错误处理 10.5.1 std::optional作为monad 10.5.2 expected作为monad 10.5.3 try monad 10.6 monad 状态处理 10.7 并发和延续monad 10.7.1 future 作为monad10.7.2 future 的实现 10.8 monad 组合总结 第11 章 模板元编程 11.1 编译时操作类型 11.1.1 推断类型调试 11.1.2 编译时的模式匹配 11.1.3 提供类型的元信息11.2 编译时检查类型的属性 11.3 构造科里化函数11.3.1 调用所有可调用的11.4 DSL 构建块 总结第12 章 并发系统的函数式设计 12.1 Actor 模型：组件思想 12.2 创建简单的消息源 12.3 将反应流建模为monad12.3.1 创建宿（Sink）接收消息12.3.2 转换反应流12.3.3 创建给定值的流12.3.4 连接流12.4 过滤反应流 12.5 反应流的错误处理 12.6 响应客户端 12.7 创建状态可修改的Actor 12.8 用Actor 编写分布式系统总结 第13 章 测试与调试13.1 程序编译正确吗？13.2 单元测试与纯函数13.3 自动产生测试
