计算机科学优选技术译丛Kotlin编程之美 PDF下载 [法]皮埃尔-伊夫斯·索蒙特 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711165040
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711165040
<p>书名:计算机科学优选技术译丛Kotlin编程之美</p><p>作者:[法] 皮埃尔-伊夫斯·索蒙特</p><p>页数:376</p><p>定价:¥119.0</p><p>出版社:机械工业出版社</p><p>出版日期:2020-05-01</p><p>ISBN:9787111650409</p><p><h2>本书特色</h2></p>[<p>
作为Java开发人员，维护糟糕的遗留代码、解释晦涩的注释、反复编写相同的样板文件可能会让编程失去乐趣。《Kotlin编程之美》讲述用Kotlin编写易于理解、易于维护、安全的程序的方法和技巧。在本书中，经验丰富的工程师皮埃尔-伊夫斯?索蒙特将以全新的、以函数式编程的视角来处理常见的编程挑战，并用示例深入讲解如何正确处理错误和数据、如何管理状态以及如何利用惰性。<br/>《Kotlin编程之美》的内容包括编程功能、处理可选数据、安全处理错误和异常以及处理和共享状态突变等。《Kotlin编程之美》的读者对象为中级Java或Kotlin开发人员、高等院校计算机相关专业学生以及对安全编程感兴趣的工程技术人员等。
                                        </p>]<p><h2>内容简介</h2></p>[<p>作为Java开发人员，维护糟糕的遗留代码、解释晦涩的注释、反复编写相同的样板文件可能会让编程失去乐趣。《Kotlin编程之美》讲述用Kotlin编写易于理解、易于维护、安全的程序的方法和技巧。在本书中，经验丰富的工程师皮埃尔-伊夫斯?索蒙特将以全新的、以函数式编程的视角来处理常见的编程挑战，并用示例深入讲解如何正确处理错误和数据、如何管理状态以及如何利用惰性。《Kotlin编程之美》的内容包括编程功能、处理可选数据、安全处理错误和异常以及处理和共享状态突变等。《Kotlin编程之美》的读者对象为中级Java或Kotlin开发人员、高等院校计算机相关专业学生以及对安全编程感兴趣的工程技术人员等。</p>]<p><h2>目录</h2></p>
    目 录封 面译者序致 谢前 言关于本书关于读者关于封面插图第1章 让程序更安全1.1 编程陷阱1.1.1 安全的处理作用1.1.2 用引用透明性使程序更安全1.2 安全编程的好处1.2.1 使用替换模型对程序进行推理1.2.2 应用安全原则的简单示例1.2.3 将抽象推向极限1.3 本章小结第2章 Kotlin中的函数式编程:概述2.1 Kotlin中的字段和变量2.1.1 省略类型以简化2.1.2 使用可变字段2.1.3 理解延迟初始化2.2 Kotlin中的类和接口2.2.1 使代码更加简洁2.2.2 实现接口或扩展类2.2.3 实例化一个类2.2.4 重载属性构造函数2.2.5 创建equals和hashCode方法2.2.6 解构数据对象2.2.7 在Kotlin中实现静态成员2.2.8 使用单例模式2.2.9 防止工具类实例化2.3 Kotlin没有原语2.4 Kotlin的两种集合类型2.5 Kotlin的包2.6 Kotlin的可见性2.7 Kotlin中的函数2.7.1 函数声明2.7.2 使用局部函数2.7.3 覆盖函数2.7.4 使用扩展函数2.7.5 使用lamdba表达式2.8 Kotlin中的null2.8.1 处理可空类型2.8.2 Elvis和默认值2.9 程序流程和控制结构2.9.1 使用条件选择器2.9.2 使用多条件选择器2.9.3 使用循环2.10 Kotlin的未检查异常2.11 自动关闭资源2.12 Kotlin的智能转换2.13 相等性VS一致性2.14 字符串插值2.15 多行字符串2.16 型变:参数化类型和子类型2.16.1 为什么型变是一个潜在的问题2.16.2 何时使用协变以及何时使用逆变2.16.3 声明端型变与使用端型变2.17 本章小结第3章 用函数编程3.1 函数是什么?3.1.1 理解两个函数集之间的关系3.1.2 Kotlin中反函数概述3.1.3 处理偏函数3.1.4 理解函数复合3.1.5 使用多参数函数3.1.6 柯里化函数3.1.7 使用偏应用函数3.1.8 没有作用的函数3.2 Kotlin中的函数3.2.1 将函数理解为数据3.2.2 将数据理解为函数3.2.3 使用对象构造函数作为函数3.2.4 使用Kotlin的fun函数3.2.5 使用对象表示法和函数表示法3.2.6 使用值函数3.2.7 使用函数引用3.2.8 复合函数3.2.9 重用函数3.3 高级函数特征3.3.1 多参数函数如何?3.3.2 应用柯里化函数3.3.3 实现高阶函数3.3.4 创建多态高阶函数3.3.5 使用匿名函数3.3.6 定义局部函数3.3.7 实现闭包3.3.8 应用偏函数和自动柯里化3.3.9 切换偏应用函数的参数3.3.10 声明单位函数3.3.11 使用正确的类型3.4 本章小结 第4章 递归、尾递归和记忆化4.1 共递归与递归4.1.1 实现共递归4.1.2 实现递归4.1.3 区分递归函数和共递归函数4.1.4 选择递归或尾递归4.2 尾调用消除4.2.1 使用尾调用消除4.2.2 从循环切换到共递归4.2.3 使用递归值函数4.3 递归函数和列表4.3.1 使用双递归函数4.3.2 对列表抽象递归4.3.3 反转列表4.3.4 构建共递归列表4.3.5 严格的后果4.4 记忆化4.4.1 在基于循环的编程中使用记忆化4.4.2 在递归函数中使用记忆化4.4.3 使用隐式记忆化4.4.4 使用自动记忆化4.4.5 实现多参数函数的记忆化4.5 记忆函数纯吗?4.6 本章小结第5章 用列表处理数据5.1 如何对数据集合进行分类5.2 不同类型的列表5.3 相对期望列表性能5.3.1 用时间来交换内存空间和复杂性5.3.2 避免就地突变5.4 KOTLIN有哪些可用列表?5.4.1 使用持久数据结构5.4.2 实现不可变的、持久的单链表5.5 列表操作中的数据共享5.6 更多列表操作5.6.1 标注的益处5.6.2 连接列表5.6.3 从列表末尾删除5.6.4 使用递归对具有高阶函数(HOFs)的列表进行折叠5.6.5 使用型变5.6.6 创建foldRight的一个栈安全递归版本5.6.7 映射和过滤列表5.7 本章小结第6章 处理可选数据6.1 空指针问题6.2 Kotlin如何处理空引用6.3 空引用的替代方法6.4 使用OPTION类型6.4.1 从一个Option中获取值6.4.2 将函数应用于可选值6.4.3 处理Option组合6.4.4 Option用例6.4.5 其他组合选项的方法6.4.6 用Option组合List6.4.7 何时使用Option6.5 本章小结第7章 处理错误和异常7.1 数据缺失的问题7.2 Either类型7.3 Result类型7.4 Result模式7.5 高级Result处理7.6 映射Failture7.7 添加工厂函数7.8 应用作用7.9 高级结果组合7.10 本章小结第8章 高级列表处理8.1 长度问题8.2 性能问题8.3 记忆化的好处8.3.1 处理记忆化的缺点8.3.2 评估性能改进8.4 List和Result组成8.4.1 处理List返回Result8.4.2 从List转换为Result8.5 常见列表抽象8.5.1 压缩和解压缩列表8.5.2 通过索引访问元素8.5.3 列表分裂8.5.4 搜索子列表8.5.5 处理列表的其它函数8.6 列表的自动并行处理8.6.1 并不是所有的计算都可以并行化8.6.2 将列表分解为子列表8.6.3 并行处理子列表8.7 本章小结第9章 与惰性配合9.1 严格VS惰性9.2 Kotlin和严格9.3 Kotlin和惰性9.4 懒惰的实现9.4.1 组合惰性值9.4.2 提升函数9.4.3 映射和flatMapping惰性9.4.4 用列表组成惰性9.4.5 处理异
