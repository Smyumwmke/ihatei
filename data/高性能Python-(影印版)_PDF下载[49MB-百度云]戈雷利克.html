高性能Python-(影印版) PDF下载 戈雷利克 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#756415385
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#756415385
<p>书名:高性能Python-(影印版)</p><p>作者:戈雷利克</p><p>页数:351</p><p>定价:¥78.0</p><p>出版社:东南大学出版社</p><p>出版日期:2015-02-01</p><p>ISBN:9787564153854</p><p><h2>本书特色</h2></p>[<p>
    你的python代码也许运行正确，但是你需要运行得更快速。通过探讨隐藏在设计备选方案中的基础理论，戈雷利克和欧日沃尔德编著的《高性能python》将帮助你更深入地理解python的实现。你将了解如何定位性能瓶颈，从而显著提升高数据流量程序中的代码执行效率。
    你该如何利用多核架构和集群？或者你该如何搭建一个可以自由伸缩而不会影响可靠性的系统？有经验的python程序员将会学习到这类问题的具体解决方案，以及来自于各个公司的如何把高性能python用于社交媒体分析、产品机器学习和其他场景中去的曲折故事。
                                        </p>]<p><h2>目录</h2></p>
    preface1. understanding performant python　the fundamental computer system　computing units　memory units　communications layers　putting the fundamental elements together　idealized computing versus the python virtual machine　so why use python?2. profiling to find bottlenecks　profiling efficiently　introducing the julia set　calculating the full julia set　simple approaches to timing--print and a decorator　simple timing using the unix time command　using the cprofile module　using runsnakerun to visualize cprofile output　using line_profiler for line-by-line measurements　using memory_profiler to diagnose memory usage　inspecting objects on the heap with heapy　using dowser for live graphing of instantiated variables　using the dis module to examine cpython bytecode　different approaches, different complexity　unit testing during optimization to maintain correctness　no-op @profile decorator　strategies to profile your code successfully　wrap-up3. lists and tuples　a more efficient search　lists versus tuples　lists as dynamic arrays　tuples as static arrays　wrap-up4. dictionaries and sets　how do dictionaries and sets work?　inserting and retrieving　deletion　resizing　hash functions and entropy　dictionaries and namespaces　wrap-up5. iterators and generators　iterators for infinite series　lazy generator evaluation　wrap-up6. matrix and vector computation　introduction to the problem　aren't python lists good enough?　problems with allocating too much　memory fragmentation　understanding perf　making decisions with perf's output　enter numpy　applying numpy to the diffusion problem　memory allocations and in-place operations　selective optimizations: finding what needs to be fixed　numexpr: making in-place operations faster and easier　a cautionary tale: verify "optimizations" (scipy)　wrap-up7. compiling to c　what sort of speed gains are possible?　jit versus aot compilers　why does type information help the code run faster?　using a c compiler　reviewing the julia set example　cvthon　compiling a pure-python version using cython　cython annotations to analyze a block of code　adding some type annotations　shed skin　building an extension module　the cost of the memory copies　cython and numpy　parauelizing the solution with openmp on one machine　numba　pythran　pypy　garbage collection differences　running pypy and installing modules　when to use each technology　other upcoming projects　a note on graphics processing units (gpus)　a wish for a future compiler project　foreign function interfaces　ctypes　cffi　f2py　cpython module　wrap-up8. concurrency　introduction to asynchronous programming　serial crawler　gevent　tornado　asyncio　database example　wrap-up9. lhe multiprocessing module　an overview of the multiprocessing module　estimating pi using the monte carlo method　estimating pi using processes and threads　using python objects　random numbers in parallel systems　using numpy　finding prime numbers　queues of work　verifying primes using interprocess communication　serial solution　naive pool solution　a less naive pool solution　using manager.value as a flag　using redis as a flag　using rawvalue as a flag　using mmap as a flag　using mmap as a flag redux　sharing numpy data with multiprocessing　synchronizing file and variable access　file locking　locking a value　wrap-up10. clusters and job queues　benefits of clustering　drawbacks of clustering　$462 million wall street loss through poor cluster upgrade strategy　skype's 24-hour global outage　common cluster designs　how to start a clustered solution　ways to avoid pain when using clusters　three clustering solutions　using the parallel python module for simple local clusters　using ipython parallel to support research　nsq for robust production clustering　queues　pub/sub　distributed prime calculation　other clustering tools to look at　wrap-up11. using less ram　objects for primitives are expensive　the array module stores many primitive objects cheaply　understanding the ram used in a collection　bytes versus unicode　efficiently storing lots of text in ram　trying these approaches on 8 million tokens　tips for using less ram　probabilistic data structures　very approximate counting with a 1-byte morris counter　k-minimum values　bloom filters　loglog counter　real-world example12. lessons from the field　adaptive lab's social media analytics (soma)　python at adaptive lab　soma's design　our development methodology　maintaining soma　advice for fellow engineers　making deep learning fly with radimrehurek.com　the sweet spot　lessons in optimizing　wrap-up　large-scale productionized machine learning at lyst.com　pythons place at lyst　cluster design　code evolution in a fast-moving start-up　building the recommendation engine　reporting and monitoring　some advice　large-scale social media analysis at smesh　pythons role at smesh　the platform　high performance real-time string matching　reporting, monitoring, debugging, and deployment　pypy for successful web and data processing systems　prerequisites　the database　the web application　ocr and translation　task distribution and workers　conclusion　task queues at lanyrd.com　python's role at lanyrd　making the task queue performant　reporting, monitoring, debugging, and deployment　advice to a fellow developer　index
