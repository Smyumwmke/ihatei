高性能计算技术丛书基于CUDA的GPU并行程序开发指南 PDF下载 [美]托尔加·索亚塔TolgaSoya 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711163061
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711163061
<p>书名:高性能计算技术丛书基于CUDA的GPU并行程序开发指南</p><p>作者:[美]托尔加·索亚塔Tolga Soya</p><p>页数:0</p><p>定价:¥179.0</p><p>出版社:机械工业出版社</p><p>出版日期:2018-05-01</p><p>ISBN:9787111630616</p><p><h2>内容简介</h2></p>[<p>近10年来，随着大数据、深度学习等相关领域的发展，对计算能力的需求呈几何级数增长。与此同时，大规模集成电路的发展却受到功耗、散热、晶体管尺寸等客观因素的，难以继续维持摩尔定律。因此，人们逐渐把目光转向了并行系统。GPU自诞生之日起就是为计算机的图形图像渲染等大规模并行处理任务而服务的，因而越来越受到研究界和企业界的关注。随着CUDA等计算架构模型的出现，这一趋势更加明显。CUDA（Compute Unified Device Architecture，统一计算设备架构）是Nvidia（英伟达）提出的并行计算架构，它可以结合CPU和GPU的优点，处理大规模的计算密集型任务。同时，它采用了基于C语言风格的语法，又将CPU端和GPU端的开发有效地集成到了同一环境中，对于大多数C程序员来说，使用十分方便，因而一经推出就迅速占领了GPU开发环境的市场。然而，会写CUDA程序与会写好的CUDA程序相差甚远！阻碍CUDA程序获得高性能的原因有很多。首先，GPU属于单指令多数据类型的并行计算，因而任务切分方式很好关键，既要充分挖掘线程级的并行性，也要充分利用流来实现任务级的并行。其次，GPU的存储类型和访问模式比CPU的要丰富得多，一个成功的CUDA程序要能充分利用不同类型的存储。再次，Nvidia GPU的架构还处于高速发展期，新一代GPU所推出的新功能也能够有效地提升计算效率。很后，万丈高楼平地起并不是CUDA开发的很好方式，Nvidia和一些第三方机构都开发了很多基于CUDA的支撑库，利用好这些第三方库可以让你的开发过程事半功倍。Tolga Soyata结合他10多年的CUDA教学经验以及与Nvidia多年合作的经历精心撰写了本书，针对上述问题进行了详细而生动的阐述。本书很独特的地方是它在部分中通过CPU多线程解释并行计算，使没有太多并行计算基础的读者也能毫无阻碍地进入CUDA天地。第二部分重点介绍了基于CUDA的GPU大规模并行程序的开发与实现。与现有的同类书籍相比，本书的特点是在多个Nvidia GPU平台（Fermi、Kepler、Maxwell和Pascal）上并行化，并进行性能分析，帮助读者理解GPU架构对程序性能的影响。第三部分介绍了一些重要的CUDA库，比如cuBLAS、cuFFT、NPP和Thrust（2章）；OpenCL编程语言（3章）；使用其他编程语言和API库进行GPU编程，包括Python、Metal、Swift、OpenGL、OpenGL ES、OpenCV和微软HLSL（4章）；当下流行的深度学习库cuDNN（5章）。本书通过生动的类比、大量的代码和详细的解释向读者循序渐进地介绍了基于CUDA编程开发的GPU并行计算方法，内容丰富翔实，适合所有具备基本的C语言知识的程序员阅读，也适合作为GPU并行计算相关课程的教材。</p>]<p><h2>作者简介</h2></p>[<p>Tolga Soyata于1988年在伊斯坦布尔技术大学电子与通信工程系获得学士学位，1992年在美国马里兰州巴尔的摩的约翰·霍普金斯大学电气与计算机工程系（ECE）获得硕士学位，2000年在罗切斯特大学电气与计算机工程系获得博士学位。2000年至2015年间，他成立了一家IT外包和复印机销售/服务公司。在运营公司的同时，他重返学术界，在罗切斯特大学电气与计算机工程系担任研究员。之后，他成为助理教授，并一直担任电气与计算机工程系教职研究人员至2016年。在罗切斯特大学电气与计算机工程系任职期间，他指导了三名博士研究生。其中两人在他的指导下获得博士学位，另一位在他2016年加入纽约州立大学奥尔巴尼分校担任电气与计算机工程系副教授时留在了罗切斯特大学。Soyata的教学课程包括大规模集成电路、模拟电路以及使用FPGA和GPU进行并行编程。他的研究兴趣包括信息物理系统、数字健康和高性能医疗移动云计算系统等。<br/>Tolga Soyata从2009年开始从事GPU编程的教学，当时他联系Nvidia将罗切斯特大学认证为CUDA教学中心（CTC）。在Nvidia将罗切斯特大学认证为教学中心后，他成为主要负责人。之后，Nvidia还将罗切斯特大学认证为CUDA研究中心（CRC），他也成为项目负责人。Tolga Soyata在罗切斯特大学担任这些计划的负责人直到他于2016年加入纽约州立大学奥尔巴尼分校。这些计划后来被Nvidia命名为GPU教育中心和GPU研究中心。在罗切斯特大学期间，他讲授了5年GPU编程和高级GPU项目开发课程，这些课程同时被列入电气与计算机工程系以及计算机科学与技术系的课程体系。自2016年加入纽约州立大学奥尔巴尼分校以来，他一直在讲授类似的课程。本书是他在两所大学讲授GPU课程的经验结晶。</p>]<p><h2>目录</h2></p>
    译者序前言关于作者**部分　理解CPU的并行性第1章　CPU并行编程概述  21.1　并行编程的演化  21.2　核心越多，并行性越高  31.3　核心与线程  41.3.1　并行化更多的是线程还是核心  51.3.2　核心资源共享的影响  61.3.3　内存资源共享的影响  61.4　**个串行程序  71.4.1 　理解数据传输速度  81.4.2　imflip.c中的main( )函数  91.4.3　垂直翻转行：FlipImageV( )  101.4.4　水平翻转列：FlipImageH( )  111.5　程序的编辑、编译、运行  121.5.1　选择编辑器和编译器  121.5.2　在Windows 7、8、10平台上开发  121.5.3　在Mac平台上开发  141.5.4　在Unix平台上开发  141.6　Unix速成  151.6.1　与目录相关的Unix命令  151.6.2　与文件相关的Unix命令  161.7　调试程序  191.7.1　gdb  191.7.2　古典调试方法  201.7.3　valgrind  221.8　**个串行程序的性能  221.8.1　可以估计执行时间吗  231.8.2　代码执行时OS在做什么  231.8.3　如何并行化  241.8.4　关于资源的思考  25第2章　开发**个CPU并行程序  262.1　**个并行程序  262.1.1　imflipP.c中的main( )函数  272.1.2　运行时间  282.1.3　imflipP.c中main( )函数代码的划分  282.1.4　线程初始化  302.1.5　创建线程  312.1.6 　线程启动/执行  322.1.7　线程终止（合并）  332.1.8　线程任务和数据划分  342.2　位图文件  352.2.1　BMP是一种无损/不压缩的文件格式  352.2.2　BMP图像文件格式  362.2.3　头文件ImageStuff.h  372.2.4　ImageStuff.c中的图像操作函数  382.3　执行线程任务  402.3.1　启动线程  412.3.2　多线程垂直翻转函数MTFlipV( )  432.3.3　FlipImageV( )和MTFlipV( )的比较  462.3.4　多线程水平翻转函数MTFlipH(?)  472.4　多线程代码的测试/计时  49第3章　改进**个CPU并行程序  513.1　程序员对性能的影响  513.2　CPU对性能的影响  523.2.1　按序核心与乱序核心  533.2.2　瘦线程与胖线程  553.3　imf?lipP的性能  553.4　操作系统对性能的影响  563.4.1　创建线程  573.4.2　线程启动和执行  573.4.3　线程状态  583.4.4　将软件线程映射到硬件线程  593.4.5　 程序性能与启动的线程  603.5　改进imf?lipP  613.5.1　 分析MTFlipH( )中的内存访问模式  623.5.2 　MTFlipH( )的多线程内存访问  633.5.3 　DRAM访问的规则  643.6　imf?lipPM：遵循DRAM的规则  653.6.1　imflipP的混乱内存访问模式  653.6.2　改进imflipP的内存访问模式  653.6.3　MTFlipHM( )：内存友好的MTFlipH( )  663.6.4　MTFlipVM( )：内存友好的MTFlipV( )  693.7　imflipPM.C的性能  693.7.1　imflipP.c和imflipPM.c的性能比较  703.7.2　速度提升：MTFlipV( )与MTFlipVM( )  713.7.3　速度提升：MTFlipH( )与MTFlipHM( )  713.7.4　理解加速：MTFlipH( )与MTFlipHM( )  713.8　进程内存映像  723.9　英特尔MIC架构：Xeon Phi  743.10　GPU是怎样的  753.11　本章小结  76第4章　理解核心和内存  774.1　曾经的英特尔  774.2　CPU和内存制造商  784.3　动态存储器与静态存储器  794.3.1　静态随机存取存储器（SRAM）  794.3.2　 动态随机存取存储器（DRAM）  794.3.3　DRAM接口标准  794.3.4　DRAM对程序性能的影响  804.3.5　SRAM对程序性能的影响  814.4　图像旋转程序：imrotate.c  814.4.1　imrotate.c的说明  824.4.2　imrotate.c：参数限制和简化  824.4.3　imrotate.c：实现原理  834.5　imrotate的性能  874.5.1　线程效率的定性分析  874.5.2　定量分析：定义线程效率  874.6　计算机的体系结构  894.6.1　核心、L1$和L2$  894.6.2　核心内部资源  904.6.3 　共享L3高速缓存（L3 $）  914.6.4　内存控制器  924.6.5　主存  924.6.6　队列、非核心和I/O  934.7　imrotateMC：让imrotate更高效  94 4.7.1　Rotate2( )：平方根和浮点除法有多差  964.7.2　Rotate3( )和Rotate4( )：sin( )和cos( )有多差  974.7.3　Rotate5( )：整数除法/乘法有多差  984.7.4　Rotate6( )：合并计算  1004.7.5　Rotate7( )：合并更多计算  1004.7.6　imrotateMC的总体性能  1014.8　本章小结  103第5章　线程管理和同步  1045.1　边缘检测程序：imedge.c  1045.1.1　imedge.c的说明  1055.1.2　imedge.c：参数限制和简化  1065.1.3　imedge.c：实现原理  1065.2　imedge.c：实现  1085.2.1　初始化和时间戳  1095.2.2　不同图像表示的初始化函数  1105.2.3　启动和终止线程  1115.2.4　高斯滤波  1125.2.5　Sobel  1135.2.6　阈值过滤  1145.3　imedge的性能  1155.4　imedgeMC：让imedge更高效  1165.4.1　利用预计算降低带宽  1165.4.2　存储预计算的像素值  1175.4.3　预计算像素值  1185.4.4　读取图像并预计算像素值  1195.4.5　PrGaussianFilter  1
