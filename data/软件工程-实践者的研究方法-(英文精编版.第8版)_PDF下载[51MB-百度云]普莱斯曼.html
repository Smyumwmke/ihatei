软件工程-实践者的研究方法-(英文精编版.第8版) PDF下载 普莱斯曼 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711149931
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711149931
<p>书名:软件工程-实践者的研究方法-(英文精编版.第8版)</p><p>作者:普莱斯曼</p><p>页数:577</p><p>定价:¥79.0</p><p>出版社:机械工业出版社</p><p>出版日期:2016-01-01</p><p>ISBN:9787111499312</p><p><h2>本书特色</h2></p>[<p>
本书自1982年发行第1版以来，一直受到软件工程界的高度重视，成为高等院校计算机相关专业软件工程课的重要教学参考书。近30年来，它的各个后继版本一直都是软件专业人土熟悉的读物，在国际软件工程界享有无可质疑的权威地位。它在全面而系统、概括而清晰地介绍软件工程的有关概念、原则、方法和工具方面获得了广大读者的好评。此外，本书在给出传统的、对学科发展具有深刻影响的方法时，又适当地介绍了当前正在发展的、具有生命力的新技术。
                                        </p>]<p><h2>目录</h2></p>
    table of contentschapter 1 the nature of software  11.1 the nature of software  31.1.1 de ning software  41.1.2 software application domains  61.1.3 legacy software  71.2 the changing nature of software  91.2.1 webapps  91.2.2 mobile applications  91.2.3 cloud computing  101.2.4 product line software  11problems and points to ponder  12further readings and information sources  12chapter 2 software engineering  142.1 de ning the discipline  152.2 the software process  162.2.1 the process framework  172.2.2 umbrella activities  182.2.3 process adaptation  182.3 software engineering practice  192.3.1 the essence of practice  192.3.2 general principles  212.4 software development myths  232.5 how it all starts  26problems and points to ponder  27further readings and information sources  27part one the software process  29chapter 3 software process structure  303.1 a generic process model  313.2 de ning a framework activity  323.3 identifying a task set  343.4 process patterns  35problems and points to ponder  37further readings and information sources  38chapter 4 process models  394.1 pre******ive process models  404.1.1 the waterfall model  404.1.2 incremental process models  424.1.3 evolutionary process models  444.1.4 concurrent models  484.1.5 a final word on evolutionary processes  504.2 specialized process models  514.2.1 component-based development  524.2.2 the formal methods model  524.2.3 aspect-oriented software development  534.3 the uni ed process  544.3.1 a brief history  554.3.2 phases of the uni ed process  554.4 product and process  57problems and points to ponder  59further readings and information sources  59chapter 5 agile development  605.1 what is agility?  625.2 agility and the cost of change  625.3 what is an agile process  63?5.3.1 agility principles  645.3.2 the politics of agile development  655.4 extreme programming  665.4.1 the xp process  665.4.2 industrial xp  695.5 other agile process models  715.5.1 scrum  725.5.2 dynamic systems development method  735.5.3 agile modeling  745.5.4 agile uni ed process  765.6 a tool set for the agile process  77problems and points to ponder  78further readings and information sources  79chapter 6 human aspects of software engineering  816.1 characteristics of a software engineer  826.2 the psychology of software engineering  836.3 the software team  846.4 team structures  866.5 agile teams  876.5.1 the generic agile team  876.5.2 the xp team  886.6 the impact of social media  896.7 software engineering using the cloud  916.8 collaboration tools  926.9 global teams  93problems and points to ponder  94further readings and information sources  95part two modeling  97chapter 7 understanding requirements  987.1 requirements engineering  997.2 establishing the groundwork  1057.2.1 identifying stakeholders  1067.2.2 recognizing multiple viewpoints  1067.2.3 working toward collaboration  1077.2.4 asking the first questions  1077.3 eliciting requirements  1087.3.1 collaborative requirements gathering  1097.3.2 quality function deployment  1127.3.3 usage scenarios  1127.3.4 elicitation work products  1137.3.5 agile requirements elicitation  1147.3.6 service-oriented methods  1147.4 developing use cases  1157.5 building the analysis model  1207.5.1 elements of the analysis model  1207.5.2 analysis patterns  1237.5.3 agile requirements engineering  1247.5.4 requirements for self-adaptive systems  1247.6 avoiding common mistakes  125problems and points to ponder  125further readings and other information sources  126chapter 8 requirements modeling: scenario-based methods  1288.1 requirements analysis  1298.1.1 overall objectives and philosophy  1308.1.2 analysis rules of thumb  1318.1.3 domain analysis  1328.1.4 requirements modeling approaches  1338.2 scenario-based modeling  1358.2.1 creating a preliminary use case  1358.2.2 re ning a preliminary use case  1388.2.3 writing a formal use case  1398.3 uml models that supplement the use case  1418.3.1 developing an activity diagram  1428.3.2 swimlane diagrams  143problems and points to ponder  144further readings and information sources  145chapter 9 requirements modeling: class-based methods  1469.1 identifying analysis classes  1479.2 specifying attributes  1509.3 de ning operations  1519.4 class-responsibility-collaborator modeling  1549.5 associations and dependencies  1609.6 analysis packages  161problems and points to ponder  162further readings and information sources  163chapter 10 requirements modeling: behavior, patterns, and燱eb/mobile apps  16410.1 creating a behavioral model  16510.2 identifying events with the use case  16510.3 state representations  16610.4 patterns for requirements modeling  16910.4.1 discovering analysis patterns  17010.4.2 a requirements pattern example: actuator-sensor  171problems and points to ponder  175further readings and information sources  176chapter 11 design concepts  17711.1 design within the context of software engineering  17811.2 the design process  18111.2.1 software quality guidelines and attributes  18111.2.2 the evolution of software design  18311.3 design concepts  18411.3.1 abstraction  18511.3.2 architecture  18511.3.3 patterns  18611.3.4 separation of concerns  18711.3.5 modularity  18711.3.6 information hiding  18811.3.7 functional independence  18911.3.8 re nement  19011.3.9 aspects  19011.3.10 refactoring  19111.3.11 object-oriented design concepts  19111.3.12 design classes  19211.3.13 dependency inversion  19411.3.14 design for test  19511.4 the design model  19611.4.1 data design elements  19711.4.2 architectural design elements  19711.4.3 interface design elements  19811.4.4 component-level design elements  20011.4.5 deployment-level design elements  201problems and points to ponder  202further readings and information sources  203chapter 12 architectural design  20412.1 software architecture  20512.1.1 what is architecture  20512.1.2 why is architecture important  20612.1.3 architectural de******ions  20712.1.4 architectural decisions  20812.2 architectural genres  20912.3 architectural styles  21012.3.1 a brief taxonomy of architectural styles  21012.3.2 architectural patterns  21512.3.3 organization and re nement  21512.4 architectural considerations  21612.5 architectural decisions  21812.6 architectural design  21912.6.1 representing the system in context  21912.6.2 de ning archetypes  22112.6.3 re ning the architecture into components  22212.6.4 describing instantiations of the system  22412.6.5 architectural design for web apps  22512.6.6 architectural design for mobile apps  22612.7 assessing alternative architectural designs  22612.7.1 architectural de******ion languages  22812.7.2 architectural reviews  22912.8 lessons learned  23012.9 pattern-based architecture review  23012.10 architecture conformance checking  23112.11 agility and architecture  232problems and points to ponder  234further readings and information sources  234chapter 13 component-level design  23613.1 what is a component  23713.1.1 an object-oriented view  23713.1.2 the traditional view  23913.1.3 a process-related view  24213.2 designing class-based components  24213.2.1 basic design principles  24313.2.2 component-level design guidelines  24613.2.3 cohesion  24713.2.4 coupling  24913.3 conducting component-level design  25013.4 component-level design for webapps  25613.4.1 content design at the component level  25713.4.2 functional design at the component level  25713.5 designing traditional components  25713.6 component-based development  25813.6.1 domain engineering  25913.6.2 component quali cation, adaptation, and composition  25913.6.3 architectural mismatch  26113.6.4 analysis and design for reuse  26213.6.5 classifying and retrieving components  262problems and points to ponder  264further readings and information sources  264chapter 14 user interface design  26614.1 the golden rules  26714.1.1 place the user in control  26714.1.2 reduce the user抯 memory load  26814.1.3 make the interface consistent  27014.2 user interface analysis and design  27114.2.1 interface analysis and design models  27114.2.2 the process  27214.3 interface analysis  27414.3.1 user analysis  27414.3.2 task analysis and modeling  27514.3.3 analysis of display content  28014.3.4 analysis of the work environment  28014.4 interface design steps  28114.4.1 applying interface design steps  28114.4.2 user interface design patterns  28314.4.3 design issues  28414.5 design evaluation  286problems and points to ponder  288further readings and information sources  289part three quality management  291chapter 15 quality concepts  29215.1 what is quality  29315.2 software quality  29415.2.1 garvin抯 quality dimensions  29515.2.2 mccall抯 quality factors  29615.2.3 iso 9126 quality factors  29815.2.4 targeted quality factors  29815.2.5 the transition to a quantitative view  30015.3 the software quality dilemma  30015.3.1 揋ood enough?software  30115.3.2 the cost of quality  30215.3.3 risks  30415.3.4 negligence and liability  30515.3.5 quality and security  30515.3.6 the impact of management actions  30615.4 achieving software quality  30715.4.1 software engineering methods  30715.4.2 project management techniques  30715.4.3 quality control  30715.4.4 quality assurance  308problems and points to ponder  308further readings and information sources  309chapter 16 software quality assurance  31016.1 background issues  31116.2 elements of software quality assurance  31216.3 sqa processes and product characteristics  31416.4 sqa tasks, goals, and metrics  31416.4.1 sqa tasks  31516.4.2 goals, attributes, and metrics  31616.5 formal approaches to sqa  31816.6 statistical software quality assurance  31816.6.1 a generic example  31916.6.2 six sigma for software engineering  32016.7 software reliability  32116.7.1 measures of reliability and availability  32116.7.2 software safety  32216.8 the iso 9000 quality standards  32316.9 the sqa plan  32516.10 a framework for product metrics  32516.10.1 measures, metrics, and indicators  32516.10.2 the challenge of product metrics  32616.10.3 measurement principles  32716.10.4 goal-oriented software measurement  32716.10.5 the attributes of effective software metrics  328problems and points to ponder  329further readings and information sources  330chapter 17 software testing strategies  33217.1 a strategic approach to software testing  33217.1.1 veri cation and validation  33417.1.2 organizing for software testing  33417.1.3 software testing strategy桾he big picture  33517.1.4 criteria for completion of testing  33817.2 strategic issues  33817.3 test strategies for conventional software  33917.3.1 unit testing  33917.3.2 integration testing  34117.4 test strategies for object-oriented software  34717.4.1 unit testing in the oo context  34717.4.2 integration testing in the oo context  34717.5 validation testing  34817.5.1 validation-test criteria  34817.5.2 con guration review  34917.5.3 alpha and beta testing  34917.6 system testing  35017.6.1 recovery testing  35017.6.2 security testing  35117.6.3 stress testing  35117.6.4 performance testing  35217.6.5 deployment testing  35217.7 the art of debugging  35317.7.1 the debugging process  35317.7.2 psychological considerations  35417.7.3 debugging strategies  35517.7.4 correcting the error  357problems and points to ponder  357further readings and information sources  358chapter 18 testing conventional applications  36018.1 software testing fundamentals  36118.2 internal and external views of testing  36318.3 white-box testing  36418.4 basis path testing  36418.4.1 flow graph notation  36418.4.2 independent program paths  36618.4.3 deriving test cases  36818.5 control structure testing  37018.6 black-box testing  37218.6.1 equivalence partitioning  37218.6.2 boundary value analysis  37318.7 model-based testing  374problems and points to ponder  375further readings and information sources  375chapter 19 testing object-oriented applications  37719.1 broadening the view of testing  37819.2 testing ooa and ood models  37919.2.1 correctness of ooa and ood models  37919.2.2 consistency of object-oriented models  38019.3 object-oriented testing strategies  38219.3.1 unit testing in the oo context  38219.3.2 integration testing in the oo context  38319.3.3 validation testing in an oo context  38319.4 object-oriented testing methods  38319.4.1 the test-case design implications of oo concepts  38419.4.2 applicability of conventional test-case design methods  38519.4.3 fault-based testing  38519.4.4 scenario-based test design  38619.5 testing methods applicable at the class level  38619.5.1 random testing for oo classes  38619.5.2 partition testing at the class level  38719.6 interclass test-case design  38819.6.1 multiple class testing  38819.6.2 tests derived from behavior models  390problems and points to ponder  391further readings and information sources  392chapter 20 security engineering  39320.1 analyzing security requirements  39420.2 security and privacy in an online world  39520.2.1 social media  39620.2.2 mobile applications  39620.2.3 cloud computing  39620.2.4 the internet of things  39720.3 security engineering analysis  39720.3.1 security requirement elicitation  39820.3.2 security modeling  39920.3.3 measures design  40020.3.4 correctness checks  40020.4 security assurance  40120.4.1 the security assurance process  40120.4.2 organization and management  40220.5 security risk analysis  40320.6 the role of conventional software engineering activities  40420.7 veri cation of trustworthy systems  406problems and points to ponder  408further readings and information sources  408chapter 21 software configuration management  41021.1 software con guration management  41121.1.1 an scm scenario  41221.1.2 elements of a con guration management system  41321.1.3 baselines  41321.1.4 software con guration items  41521.1.5 management of dependencies and changes  41521.2 the scm repository  41721.2.1 general features and content  41721.2.2 scm features  41821.3 the scm process  41921.3.1 identi cation of objects in the software con guration  42021.3.2 version control  42121.3.3 change control  42221.3.4 impact management  42521.3.5 con guration audit  42621.3.6 status reporting  426problems and points to ponder  427further readings and information sources  428part four managing software projects  431chapter 22 project management concepts  43222.1 the management spectrum  43322.1.1 the people  43322.1.2 the product  43422.1.3 the process  43422.1.4 the project  43422.2 people  43522.2.1 the stakeholders  43522.2.2 team leaders  43622.2.3 the software team  43722.2.4 agile teams  43922.2.5 coordination and communication issues  44022.3 the product  44122.3.1 software scope  44222.3.2 problem decomposition  44222.4 the process  44222.4.1 melding the product and the process  44322.4.2 process decomposition  44422.5 the project  44522.6 the w5hh principle  44622.7 critical practices  447problems and points to ponder  448further readings and information sources  448chapter 23 process and project metrics  45123.1 metrics in the process and project domains  45223.1.1 process metrics and software process improvement  45223.1.2 project metrics  45523.2 software measurement  45623.2.1 size-oriented metrics  45723.2.2 function-oriented metrics  45823.2.3 reconciling loc and fp metrics  45923.2.4 object-oriented metrics  46123.2.5 use case-oriented metrics  46223.3 metrics for software quality  46223.3.1 measuring quality  46323.3.2 defect removal ef ciency  464problems and points to ponder  466further readings and information sources  467chapter 24 estimation for software projects  46924.1 observations on estimation  47024.2 the project planning process  47124.3 software scope and feasibility  47224.4 resources  47324.4.1 human resources  47324.4.2 reusable software resources  47424.4.3 environmental resources  47424.5 software project estimation  47524.6 decomposition techniques  47624.6.1 software sizing  47624.6.2 problem-based estimation  47724.6.3 an example of loc-based estimation  47824.6.4 an example of fp-based estimation  48024.6.5 process-based estimation  48124.6.6 an example of process-based estimation  48224.6.7 estimation with use cases  48224.6.8 an example of estimation using use case points  48424.6.9 reconciling estimates  48424.7 empirical estimation models  48524.7.1 the structure of estimation models  48624.7.2 the cocomo ii model  48624.7.3 the software equation  48624.8 estimation for object-oriented projects  488problems and points to ponder  488further readings and information sources  489chapter 25 project scheduling  49025.1 basic concepts  49125.2 project scheduling  49325.2.1 basic principles  49425.2.2 the relationship between people and effort  49525.2.3 effort distribution  49625.3 de ning a task set for the software project  49725.3.1 a task set example  49825.3.2  re nement of major tasks  49925.4 de ning a task network  50025.5 scheduling  50125.5.1 time-line charts  50225.5.2 tracking the schedule  50325.5.3 tracking progress for an oo project  50425.6 earned value analysis  505problems and points to ponder  508further readings and information sources  509chapter 26 risk management  51026.1 reactive versus proactive risk strategies  51126.2 software risks  51126.3 risk identi cation  51326.3.1 assessing overall project risk  51426.3.2 risk components and drivers  51526.4 risk projection  51526.4.1 developing a risk table  51626.4.2 assessing risk impact  51826.5 risk re nement  52026.6 risk mitigation, monitoring, and management  52126.7 the rmmm plan  523problems and points to ponder  525further readings and information sources  526appendix 1 an introduction to uml  527appendix 2 object-oriented concepts  548references  556
