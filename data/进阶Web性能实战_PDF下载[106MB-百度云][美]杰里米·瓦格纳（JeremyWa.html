进阶Web性能实战 PDF下载 [美]杰里米·瓦格纳（JeremyWa 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711553832
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711553832
<p>书名:进阶Web性能实战</p><p>作者:[美]杰里米·瓦格纳（Jeremy Wa</p><p>页数:305</p><p>定价:¥99.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2020-06-01</p><p>ISBN:9787115538321</p><p><h2>本书特色</h2></p>[<p>
在Web 变得越来越复杂的时代，解决Web 性能问题正当时。本书旨在帮助读者创建更加快速的网站，内容涵盖Web 性能的基础知识、性能评估工具、CSS 优化、图像优化、字体优化、JavaScript 相关的内容、Brotli 压缩算法、资源提示、配置缓存策略、HTTP/2，等等。
                                        </p>]<p><h2>内容简介</h2></p>[<p>在Web 变得越来越复杂的时代，解决Web 性能问题正当时。本书旨在帮助读者创建更加快速的网站，内容涵盖Web 性能的基础知识、性能评估工具、CSS 优化、图像优化、字体优化、JavaScript 相关的内容、Brotli 压缩算法、资源提示、配置缓存策略、HTTP/2，等等。</p>]<p><h2>作者简介</h2></p>[<p>杰里米·瓦格纳（Jeremy Wagner） Web性能咨询师、Web前端开发者，在多家机构和大公司积累了十余年经验。撰写过大量Web性能方面的图书和文章，还经常在各种Web开发会议上发表演讲。</p>]<p><h2>目录</h2></p>
    第1 章 理解Web 性能 　　 11.1 理解Web 性能 　　 11.1.1 Web 性能和用户体验 　　 11.1.2 Web 浏览器如何与Web 服务器通信 　　 21.1.3 Web 页面如何加载 　　 41.2 上手准备 　　 51.2.1 安装Node.js 和Git 　　 61.2.2 下载并运行客户的网站 　　 61.2.3 模拟网络连接 　　 71.3 检查客户网站 　　 81.4 优化客户网站 　　 101.4.1 缩小资源 　　 111.4.2 使用服务器压缩 　　 131.4.3 压缩图像 　　 161.5 *终性能测试 　　 181.6 小结 　　 19第2 章 使用评估工具 　　 202.1 使用Google PageSpeed Insights 进行评估　　 202.1.1 评估网站性能 　　 202.1.2 使用Google Analytics 进行批量报告 　　 232.2 使用基于浏览器的评估工具 　　 242.3 检查网络请求 　　 252.3.1 查看计时信息 　　 252.3.2 查看HTTP 请求和响应头 　　 272.4 渲染性能检查工具 　　 292.4.1 理解浏览器如何渲染网页 　　 292.4.2 使用Google Chrome 的Performance 面板 　　 302.4.3 识别问题事件：jank 是元凶 　　 322.4.4 用JavaScript 在时间线中标记点 　　 372.4.5 其他浏览器中的渲染分析器 　　 382.5 在Chrome 中对JavaScript 进行基准测试 　　 392.6 模拟和监控设备 　　 402.6.1 在桌面Web 浏览器中模拟设备 　　 412.6.2 在Android 设备上远程调试网站 　　 422.6.3 在iOS 设备上远程调试网站 　　 432.7 创建自定义网络节流配置 　　 442.8 小结 　　 45第3 章 优化CSS 　　 473.1 直入主题，保持DRY 　　 473.1.1 简写CSS 　　 473.1.2 使用CSS 浅选择器 　　 503.1.3 挑选浅选择器 　　 513.1.4 LESS 和SASS 预编译器：简单就是美 　　 523.1.5 不要重复自己 　　 533.1.6 实现DRY 　　 533.1.7 使用csscss 查找冗余 　　 543.1.8 分割CSS 　　 563.1.9 自定义框架下载 　　 573.2 移动优先即用户优先 　　 583.2.1 移动优先与桌面优先 　　 583.2.2 Mobilegeddon 算法 　　 613.2.3 使用Google 的移动友好指南 　　 623.2.4 验证网站的移动友好性 　　 633.3 对CSS 进行性能调整 　　 633.3.1 避免使用 @import 声明 　　 633.3.2 @import 串行请求 　　 643.3.3 并行请求 　　 643.3.4 在中放置CSS 　　 653.3.5 防止无样式内容闪烁 　　 653.3.6 提高渲染速度 　　 663.3.7 使用更快的选择器 　　 663.3.8 构建和运行基准测试 　　 673.3.9 检查基准测试结果 　　 683.3.10 尽可能使用flexbox 　　 693.3.11 对比盒子模型和flexbox 样式 　　 693.3.12 检查基准测试结果 　　 703.4 使用CSS 过渡 　　 713.4.1 使用CSS 过渡 　　 713.4.2 观察CSS 过渡性能 　　 733.4.3 使用will-change 属性优化过渡 　　 743.5 小结 　　 75第4 章 理解关键CSS 　　 764.1 关键CSS 及其解决的问题 　　 764.1.1 理解折叠 　　 764.1.2 理解渲染阻塞 　　 774.2 关键CSS 的原理 　　 784.2.1 加载首屏样式 　　 794.2.2 加载首屏以外内容的样式 　　 794.3 实现关键CSS 　　 804.3.1 配置并运行菜谱网站 　　 814.3.2 识别和分离首屏CSS 　　 824.3.3 加载首屏以外内容的CSS 　　 884.4 权衡收益 　　 894.5 提升可维护性 　　 914.6 多页网站的注意事项 　　 914.7 小结 　　 92第5 章 响应式图像 　　 945.1 为什么要考虑图像传输 　　 945.2 理解图像类型及其应用 　　 965.2.1 使用光栅图像 　　 965.2.2 使用SVG 图像 　　 995.2.3 选择图像格式 　　 1005.3 CSS 中的图像传输 　　 1015.3.1 使用媒体查询在CSS 中适配显示器 　　 1015.3.2 通过媒体查询适配高DPI 显示器 　　 1045.3.3 在CSS 中使用SVG 背景图像 　　 1065.4 在HTML 中传输图像 　　 1065.4.1 图像的全局max-width规则 　　 1075.4.2 使用srcset 　　 1075.4.3 使用元素 　　 1105.4.4 使用Picturefill 提供polyfill支持 　　 1145.4.5 在HTML 中使用SVG 　　 1165.5 小结 　　 117第6 章 图像的进一步处理　　 1186.1 使用图像雪碧图 　　 1186.1.1 准备工作 　　 1196.1.2 生成雪碧图 　　 1196.1.3 使用生成的雪碧图 　　 1216.1.4 使用雪碧图时的考量 　　 1226.1.5 使用Grumpicon 回退到光栅图像雪碧图 　　 1236.2 缩小图像 　　 1246.2.1 使用imagemin 优化光栅图像 　　 1256.2.2 优化SVG 图像 　　 1296.3 使用WebP 编码图像 　　 1316.3.1 使用imagemin 编码有损WebP 图像 　　 1326.3.2 使用imagemin 编码无损WebP 图像 　　 1336.3.3 支持不支持WebP 的浏览器 　　 1346.4 懒加载图像 　　 1366.4.1 配置标记 　　 1376.4.2 编写懒加载程序 　　 1386.4.3 考虑不支持JavaScript 的用户 　　 1446.5 小结 　　 146第7 章 更快的字体 　　 1487.1 明智地使用字体 　　 1497.1.1 选择字体和字体变体 　　 1497.1.2 构建你自己的@font-face级联 　　 1517.2 压缩EOT 和TTF 字体格式 　　 1547.3 取字体子集 　　 1567.3.1 手动生成字体子集 　　 1567.3.2 使用unicode-range 属性传输字体子集 　　 1607.4 优化字体加载 　　 1667.4.1 理解字体加载的问题 　　 1667.4.2 使用CSS font-display属性 　　 1687.4.3 使用字体加载API 　　 1697.4.4 使用Font Face Observer作为回退 　　 1737.5 小结 　　 175第8 章 保持JavaScript 的简洁与快速 　　 1768.1 影响脚本加载行为 　　 1768.1.1 合理放置script元素 　　 1778.1.2 使用异步脚本加载 　　 1788.1.3 使用async 　　 1788.1.4 在多脚本加载中可靠地使用async 　　 1808.2 使用更简洁的兼容jQuery 的替代方案　　 1828.2.1 比较替代方案 　　 1828.2.2 探索竞品 　　 1828.2.3 比较大小 　　 1828.2.4 比较性能 　　 1838.2.5 实现替代方案 　　 1858.2.6 使用Zepto 　　 1858.2.7 理解使用Shoestring 或Sprint的注意事项 　　 1858.3 脱离jQuery 编码 　　 1868.3.1 检查DOM 是否准备就绪 　　 1868.3.2 选择元素并绑定事件 　　 1878.3.3 使用classList 操作元素上的类 　　 1888.3.4 读取和修改元素属性与内容 　　 1898.3.5 使用Fetch API 发起AJAX请求 　　 1928.3.6 使用Fetch API 　　 1928.3.7 Fetch API 的polyfill 　　 1938.4 使用requestAnimationFrame设置动画 　　 1948.4.1 requestAnimationFrame一览 　　 1948.4.2 计时器函数驱动的动画和requestAnimationFrame 　　 1948.4.3 比较性能 　　 1958.4.4 实现requestAnimationFrame　　 1968.4.5 了解Velocity.js 　　 1988.5 小结 　　 199第9 章 使用Service Worker 提升性能 　　 2009.1 何为Service Worker 　　 2009.2 编写**个Service Worker 　　 2029.2.1 安装Service Worker 　　 2039.2.2 注册Service Worker 　　 2039.2.3 拦截并缓存网络请求 　　 2079.2.4 衡量性能收益 　　 2099.2.5 优化网络请求的拦截行为 　　 2099.3 更新Service Worker 　　 2129.3.1 文件版本控制 　　 2129.3.2 清理旧缓存 　　 2149.4 小结 　　 215第10 章 微调资源传输 　　 21710.1 压缩资源 　　 21710.1.1 遵循压缩指导原则 　　 21810.1.2 使用Brotli 压缩 　　 22110.2 缓存资源 　　 22510.2.1 理解缓存 　　 22510.2.2 制定*佳缓存策略 　　 23010.2.3 使缓存资源失效 　　 23310.3 使用CDN 资源 　　 23410.3.1 使用CDN 托管资源　　 23410.3.2 CDN 发生故障怎么办 　　 23610.3.3 使用子资源完整性验证CDN 资源 　　 23710.4 使用资源提示 　　 23910.4.1 使用preconnect 资源提示 　　 23910.4.2 使用prefetch 和preload资源提示 　　 24110.5 小结 　　 243第11 章 HTTP/2 未来展望 　　 24511.1 理解HTTP/2 的必要性 　　 24511.1.1 理解HTTP/1 中的问题 　　 24611.1.2 通过HTTP/2 解决常见的HTTP/1 问题 　　 24811.1.3 在Node 中编写一个简单的HTTP/2 服务器 　　 25111.1.4 观察收益 　　 25311.2 探索HTTP/2 对应的优化技术变化 　　 25511.2.1 资源粒度与缓存效率 　　 25511.2.2 识别HTTP/2 的性能反模式 　　 25611.3 使用服务器推送抢先发送资源 　　 25711.3.1 理解服务器推送及其工作原理 　　 25811.3.2 使用服务器推送 　　 25811.3.3 测量服务器推送性能 　　 26111.4 同时优化HTTP/1 和HTTP/2 　　 26211.4.1 HTTP/2 服务器如何处理不支持HTTP/2 的浏览器 　　 26211.4.2 划分用户 　　 26311.4.3 根据浏览器功能提供资源 　　 26411.5 小结 　　 269第12 章 使用gulp 自动化优化任务 　　 27012.1 关于gulp 　　 27012.1.1 为什么要使用构建系统 　　 27112.1.2 gulp 的工作原理 　　 27212.2 奠定基础 　　 27312.2.1 组织项目文件夹 　　 27312.2.2 安装gulp 及其插件 　　 27412.3 编写gulp 任务 　　 27712.3.1 剖析gulp 任务 　　 27712.3.2 编写核心任务 　　 27912.3.3 编写实用程序任务 　　 28512.4 深入理解gulp 插件 　　 28812.5 小结 　　 289附录A 工具参考 　　 290附录B 常用jQuery 功能的原生等价实现 　　 295
