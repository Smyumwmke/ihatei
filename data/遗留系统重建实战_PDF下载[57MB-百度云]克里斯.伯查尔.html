遗留系统重建实战 PDF下载 克里斯.伯查尔 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546585
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546585
<p>书名:遗留系统重建实战</p><p>作者:克里斯.伯查尔</p><p>页数:180</p><p>定价:¥55.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-10-01</p><p>ISBN:9787115465856</p><p><h2>本书特色</h2></p>[<p>
正如本书作者所言，大多数开发人员的主要时间都是花费在与现有的软件打交道上，而不是编写全新的应用程序。相信开发人员或多或少都遇到过与遗留系统相关的问题或者困惑，本书致力于帮开发人员回答这些问题，更重要的是，帮开发人员避免把自己当前开发的系统变成别人将来要面临的遗留问题。
本书篇幅不长，但涵盖的内容很广，例证丰富，有大量的示例代码（主要使用Java或C#编写），深入浅出地介绍了工作在遗留系统中会遇到的各种问题及应对方法。书中不仅包含技术性的内容—如何选择构建项目的工具，如何自动化构建基础设施，如何决定并进行重构或重写等，也包含非技术性的内容—应该建设什么样的团队文化，如何引入代码评审等活动，如何进行团队知识的传播、改进沟通方式等。
                                        </p>]<p><h2>内容简介</h2></p>[<p>作为开发人员，你可能会从另一个团队接手一个项目，而且该项目是基于现有代码库的，拥有很多设计模式、使用假设、基础设施和工具。幸运的是，有一些方法可以为遗留项目注入新的活力，这样你就可以维护、改进和扩展它们，而不必顾及它们的局限性。
这是一本以经验为主导的指南，能使遗留软件项目脱胎换骨。它涵盖了重构、质量度量学、工具链和工作流、持续集成、基础设施自动化以及组织文化等内容。在技术层面，读者将学习如何给代码模块化引进依赖注入，如何定量地衡量软件质量，以及如何实现基础设施的自动化。在策略层面，读者将能学到的实践有：软件是应该重写还是应该重构，团队的组织架构应该是什么样的，以及如何让管理层意识到软件质量的重要性。本书的核心议题包括解析和模块化棘手的代码结构、集成和自动化测试、替换过时的构建系统，以及用Vagrant和Ansible 之类的工具实现基础设施自动化。
本书主要内容
● 重构遗留代码库。
● 持续审查和持续集成。
● 遗留基础设施的自动化。
● 给老代码加新测试。
● 单体应用的模块化。
本书面向的读者对象是熟悉面向对象语言（如Java 或C#）的开发人员和团队领导。 </p>]<p><h2>作者简介</h2></p>[<p>作者简介
Chris Birchall 是伦敦《卫报》的高-级开发工程师，致力于为网站提供支持的后台服务。此前，他做过很多不同的项目，包括日本zui大的医疗门户网站、高性能日志管理软件、自然语言分析工具和许多移动网站。他拥有剑桥大学计算机科学专业的学士学位。
译者简介
张喻，ThoughtWorks咨询师，热爱技术，热衷编程。目前主要从事后端API的开发、部署、维护等相关工作，在整洁代码、敏捷实践和软件开发高效团队方面有丰富的理论和实践经验。
张耀丹，ThoughtWorks咨询师，曾长期参与大型遗留系统的开发与改进，在Java服务器端技术、大型系统架构演进、微服务转型、DevOps和云计算方面有丰富的经验。
禚娴静，ThoughtWorks咨询师，乐于知识分享与传播。拥有多年企业和互联网应用的开发实战经验，专注于敏捷实践、软件架构和持续交付领域，在.NET技术栈和微服务架构演化等方面有丰富的积累。</p>]<p><h2>目录</h2></p>
    目录

**部分　开始
第1章　了解遗留项目中的挑战  3
1.1  遗留项目的定义  3
1.1.1  遗留项目的特征  4
1.1.2  规则的例外  5
1.2  遗留代码  6
1.2.1  没有测试和无法测试的代码  6
1.2.2  不灵活的代码  8
1.2.3  被技术债务拖累的代码  8
1.3  遗留基础设施  9
1.3.1  开发环境  10
1.3.2  过时的依赖  10
1.3.3  异构环境  11
1.4  遗留文化  12
1.4.1  害怕变化  12
1.4.2  知识仓库  13
1.5  小结  14
第2章  找到起点  15
2.1  克服恐惧和沮丧  15
2.1.1  恐惧  16
2.1.2  沮丧  18
2.2  收集软件的有用数据  19
2.2.1  bug和编码标准违例  20
2.2.2  性能  20
2.2.3  错误计数  23
2.2.4  对常见的任务计时  23
2.2.5  常用文件  24
2.2.6  度量可度量的一切  25
2.3  用FindBugs、PMD和Checkstyle审查代码库  25
2.3.1  在IDE中运行FindBugs  26
2.3.2  处理误报  29
2.3.3  PMD和Checkstyle  32
2.4  用Jenkins进行持续审查  34
2.4.1  持续集成和持续审查  34
2.4.2  安装和设置Jenkins  35
2.4.3  用Jenkins构建和审查代码  36
2.4.4  还能用Jenkins做些什么  37
2.4.5  SonarQube  39
2.5  小结  39
第二部分　通过重构改善代码库
第3章  准备重构  43
3.1  达成团队共识  44
3.1.1  传统主义者  44
3.1.2  反传统主义者  46
3.1.3  一切都在于沟通  47
3.2  获得组织的批准  48
3.2.1  使它变得正式  48
3.2.2  备用计划：神秘的20%计划  49
3.3  选择重构目标  50
3.4  决策时间：重构还是重写  51
3.4.1  不应该重写的情况  52
3.4.2  从头重写的好处  55
3.4.3  重写的必要条件  56
3.4.4  第三种方式：增量重写  57
3.5  小结  58
第4章  重构  59
4.1  有纪律的重构  59
4.1.1  避免麦克白的悲剧  59
4.1.2  把重构和其他的工作分开  60
4.1.3  依靠IDE  61
4.1.4  依靠版本控制系统  64
4.1.5  Mikado方法  65
4.2  常见的遗留代码的特征和重构  66
4.2.1  陈旧代码  66
4.2.2  有毒的测试  68
4.2.3  过多的null  70
4.2.4  不必要的可变状态  73
4.2.5  错综复杂的业务逻辑  74
4.2.6  视图层中的复杂性  79
4.3  测试遗留代码  83
4.3.1  测试不可测试的代码  83
4.3.2  没有单元测试的回归测试  86
4.3.3  让用户为你工作  88
4.4  小结  89
第5章  重搭架构  90
5.1  什么是重搭架构  90
5.2  将单体应用程序分解为模块  92
5.2.1  案例研究—日志管理应用程序  92
5.2.2  定义模块和接口  94
5.2.3  构建脚本和依赖管理  95
5.2.4  分拆模块  96
5.2.5  引入Guice  97
5.2.6  Gradle来了  98
5.2.7  结论  98
5.3  将Web应用程序分发到服务  99
5.3.1  再看一下Orinoco.com  99
5.3.2  选择一个架构  100
5.3.3  继续采用单体架构  101
5.3.4  前后端分离  103
5.3.5  面向服务架构  106
5.3.6  微服务  108
5.3.7  Orinoco.com应该做什么  109
5.4  小结  109
第6章  大规模重写  111
6.1  决定项目范围  112
6.1.1  项目目标是什么  112
6.1.2  记录项目范围  113
6.2  从过去学习  114
6.3  如何处理数据库  115
6.3.1  共享现有数据库  116
6.3.2  创建一个新数据库  119
6.3.3  应用程序间通信  124
6.4  小结  125
第三部分　重构之外——改善项目工作流程与基础设施
第7章  开发环境的自动化  129
7.1  工作的**天  129
7.1.1  搭建用户活动仪表盘开发环境  130
7.1.2  出了什么问题  132
7.2  一个好的README文件的价值  134
7.3  用Vagrant和Ansible对开发环境进行自动化  135
7.3.1  Vagrant介绍  135
7.3.2  为用户活动仪表盘项目搭建Vagrant  136
7.3.3  用Ansible进行自动配置  137
7.3.4  添加更多的角色  139
7.3.5  移除对外部数据库的依赖  141
7.3.6  工作的**天—再来一次  142
7.4  小结  143
第8章  将自动化扩展到测试环境、预生产环境以及生产环境  144
8.1  自动化基础设施的好处  145
8.1.1  保证环境一致性  145
8.1.2  易于更新软件  145
8.1.3  易于搭建新环境  145
8.1.4  支持追踪配置更改  146
8.2  将自动化扩展到其他环境  146
8.2.1  重构Ansible脚本以处理多种环境  146
8.2.2  为Ansible角色和playbook搭建库  150
8.2.3  让Jenkins负责  152
8.2.4  常见问题  154
8.3  移到云上  155
8.3.1  不可变基础设施  156
8.3.2  DevOps  156
8.4  小结  157
第9章  对遗留软件的开发、构建以及部署过程进行现代化  158
9.1  开发、构建以及部署遗留软件的困难  158　　
9.1.1  缺乏自动化  158
9.1.2  过时的工具  160
9.2  更新工具链  160
9.3  用Jenkins实现持续集成与自动化  163
9.4  自动发布和部署  165
9.5  小结  172
第10章  停止编写遗留代码  173
10.1  源代码并不是项目的全部  173
10.2  信息不能是自由的  174
10.2.1  文档  174
10.2.2  促进沟通  175
10.3  工作是做不完的  176
10.3.1  定期进行代码评审  176
10.3.2  修复一扇窗户  176
10.4  自动化一切  177
10.5  小型为佳  178
10.6  小结  180
