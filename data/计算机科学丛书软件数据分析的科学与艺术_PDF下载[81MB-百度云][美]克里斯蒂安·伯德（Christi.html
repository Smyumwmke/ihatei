计算机科学丛书软件数据分析的科学与艺术 PDF下载 [美]克里斯蒂安·伯德（Christi 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711164760
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711164760
<p>书名:计算机科学丛书软件数据分析的科学与艺术</p><p>作者:[美] 克里斯蒂安·伯德（Christi</p><p>页数:512</p><p>定价:¥159.0</p><p>出版社:机械工业出版社</p><p>出版日期:2020-04-01</p><p>ISBN:9787111647607</p><p><h2>本书特色</h2></p>[<p>
本书深入探讨了软件数据分析的技术与艺术，来自微软、NASA等的多位软件科学家和数据科学家分享了他们的实践经验。书中内容涵盖安全数据分析、代码审查、日志文档、用户监控等，技术领域涉足共同修改分析、文本分析、主题分析以及概念分析等方面，还包括发布计划和源代码注释分析等高级主题。通过阅读本书，读者将了解如何在工业领域和开源领域应用数据分析，以及如何向利益相关者和决策者呈现数据分析结果。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书深入探讨了软件数据分析的技术与艺术，来自微软、NASA等的多位软件科学家和数据科学家分享了他们的实践经验。书中内容涵盖安全数据分析、代码审查、日志文档、用户监控等，技术领域涉足共同修改分析、文本分析、主题分析以及概念分析等方面，还包括发布计划和源代码注释分析等不错主题。通过阅读本书，读者将了解如何在工业领域和开源领域应用数据分析，以及如何向利益相关者和决策者呈现数据分析结果。</p>]<p><h2>目录</h2></p>
    出版者的话译者序本书作者第1章　软件数据分析的过去、现在与未来11.1　定义11.2　过去（起源）31.2.1　**代：初步工作31.2.2　第二代：学术实验41.2.3　第三代：工业实验41.2.4　第四代：数据科学无处不在41.3　现状51.4　结论8致谢8参考文献9**部分　技术教程第2章　利用形式概念分析挖掘模式及其违约122.1　引言122.2　模式和块132.3　计算所有块152.4　使用Colibri挖掘购物车172.5　违约192.6　查找违约202.7　是两种模式还是一种违约？212.8　性能222.9　编码顺序232.10　内联242.11　相关工作242.11.1　挖掘模式242.11.2　挖掘违约252.11.3　PR-Miner262.12　结论26致谢27参考文献27第3章　软件项目中的文本分析293.1　引言293.2　软件项目的文本数据及其检索293.2.1　文本数据293.2.2　文本检索323.3　人工编码333.3.1　编码过程343.3.2　挑战363.4　自动化分析373.4.1　主题建模373.4.2　词性标记和关系抽取383.4.3　n-gram模型393.4.4　克隆检测403.4.5　可视化423.5　两个工业案例443.5.1　需求工程的痛点：需求工程调查453.5.2　需求规约中的克隆检测493.6　结论52参考文献52第4章　从软件开发制品中合成知识544.1　问题描述544.2　软件制品生命周期模型544.2.1　示例：补丁生命周期554.2.2　模型抽取564.3　代码评审564.3.1　Mozilla项目564.3.2　WebKit项目574.3.3　Blink项目574.4　生命周期分析574.4.1　Mozilla Firefox项目574.4.2　WebKit项目604.4.3　Blink项目614.5　其他应用624.6　结论62参考文献63第5章　分析IDE使用型数据的实用指南645.1　引言645.2　使用型数据的研究概念655.2.1　使用型数据概念及其分析意义655.2.2　基于目标选择相关数据665.2.3　隐私问题665.2.4　研究范围675.3　如何收集数据675.3.1　Eclipse使用型数据收集器685.3.2　Mylyn和Eclipse Mylyn Monitor755.3.3　CodingSpectator 775.3.4　为Visual Studio创建收集工具815.4　如何分析使用型数据875.4.1　数据匿名875.4.2　使用型数据的格式875.4.3　幅度分析885.4.4　分类分析885.4.5　序列分析895.4.6　状态模型分析905.4.7　关键事件技术925.4.8　其他来源的数据935.5　使用型数据学习的局限性935.6　结论945.7　代码清单95致谢104参考文献104第6章　隐含狄利克雷分布：从软件工程数据中抽取主题1066.1　引言1066.2　LDA在软件分析中的应用1076.3　LDA工作原理1086.4　LDA教程1106.4.1　LDA来源1106.4.2　获取软件工程数据1116.4.3　文本分析和数据转换1116.4.4　LDA应用1136.4.5　LDA输出概要1136.5　陷阱和有效性威胁1176.5.1　标准有效性1176.5.2　构造有效性1196.5.3　内部有效性1196.5.4　外部有效性1206.5.5　可信性1206.6　结论120参考文献121第7章　分析产品和过程数据的工具与技术1237.1　引言1237.2　一种合理的分析流程1247.2.1　获取数据1247.2.2　选择数据1257.2.3　处理数据1267.2.4　汇总数据1277.2.5　管道系统1287.3　源代码分析1287.3.1　启发式分析1287.3.2　词法分析1297.3.3　语法和语义分析1327.3.4　第三方工具1327.4　编译代码分析1377.4.1　汇编语言1377.4.2　机器码1387.4.3　命名修饰处理1407.4.4　字节码1407.4.5　动态链接1417.4.6　库1427.5　配置管理数据分析1447.5.1　获取存储库数据1447.5.2　分析元数据1457.5.3　分析时间序列快照1487.5.4　检出库分析1507.5.5　结合文件与元数据分析1517.5.6　组装存储库1527.6　数据可视化1537.6.1　图1537.6.2　说明图1567.6.3　图表1577.6.4　地图1597.7　结论161参考文献161第二部分　关注的数据和问题第8章　安全数据分析1668.1　漏洞1668.2　安全性数据的注意事项1678.2.1　注意事项1：有漏洞是正常的1678.2.2　注意事项2：“更多的漏洞”并不总是意味着“更不安全”1678.2.3　注意事项3：设计级别的缺陷通常不会被追踪1688.2.4　注意事项4：安全性是被消极定义的1688.3　度量漏洞严重性1698.3.1　CVSS概述1698.3.2　CVSS应用示例1708.3.3　CVSS的隐患1708.4　收集、分析漏洞数据的方法1708.4.1　步骤1：追踪漏洞从报告到修复的全过程1718.4.2　步骤2：聚合源控制日志1718.4.3　步骤3：确定漏洞覆盖率1728.4.4　步骤4：根据工程错误进行分类1738.5　安全数据所提供的信息1748.5.1　漏洞的社会技术要素1748.5.2　漏洞具有长期复杂的历史1758.6　结论176参考文献176第9章　混合的挖掘代码评审数据的方法：多次提交评审与拉取请求的示例与研究1789.1　引言1789.2　使用混合方法处理的动机1789.3　评审过程和数据1799.3.1　软件审查1799.3.2　OSS代码评审1799.3.3　微软的代码评审1809.3.4　基于Google的Gerrit代码评审1809.3.5　GitHub中的拉取请求1809.3.6　数据度量和属性1819.4　定量的可重现性分析：分支的代码评审1829.4.1　研究问题1：每次评审的提交1839.4.2　研究问题2：提交的大小1839.4.3　研究问题3：评审间隔1849.4.4　研究问题4：评审者的参与过程1849.4.5　小结1859.5　定性分析方法1869.5.1　采样方法1869.5.2　数据收集1879.5.3　微软数据的定性分析1899.5.4　将扎根理论应用于归档数据以理解OSS评审1899.6　三角互证1909.6.1　使用调查来三角互证定性结果1919.6.2　Linux中多次提交的分支如何评审1929.6.3　封闭式编码：GitHub和Gerrit上的分支或修订1939.6.4　理解拉取请求为什么被拒绝1939.7　结论194参考文献195第10章　挖掘安卓应用程序中的异常19810.1　引言19810.2　基于描述对应用进行聚类20010.2.1　收集应用程序20010.2.2　基于NLP对描述进行预处理20110.2.3　基于LDA识别主题20110.2.4　基于K-means算法对应用进行聚类20310.2.5　找到*佳的集群数量20310.2.6　生成的应用程序集群20410.3　通过API识别异常20510.3.1　提取API的使用20510.3.2　敏感和罕见的API20610.3.3　基于距离的异常值检测20710.3.4　CHABADA作为恶意软件检测器20810.4　实验评估20910.4.1　RQ1：异常检测20910.4.2　RQ2：特征选择21110.4.3　RQ3：恶意软件检测21110.4.4　有效性的限制和威胁21410.5　相关工作21510.5.1　挖掘APP描述21510.5.2　行为和描述不匹配21510.5.3　检测恶意应用21610.6　结论与展望216致谢216参考文献216第11章　软件制品间的修改耦合：从历史修改中学习21911.1　引言21911.2　修改耦合22011.2.1　为什么制品要一起修改？22011.2.2　使用修改耦合的好处22111.3　修改耦合的识别方法22211.3.1　原始计数22211.3.2　关联规则22811.3.3　时间序列分析23211.4　识别修改耦合的挑战23411.4.1　提交习惯的影响23411.4.2　检测修改耦合的实用建议23511.4.3　其他方法23711.5　修改耦合的应用23811.5.1　修改预测和修改影响分析23811.5.2　设计缺陷的发现和重构24011.5.3　评估软件体系架构24311.5.4　协作需求与社会技术的一致性24311.6　结论244参考文献244第三部分　实战经验第12章　软件数据分析在工业实践中的应用：当研究遇上实践25012.1　引言25012.2　背景25112.2.1　Fraunhofer在软件度量方面的经验25112.2.2　相关术语25212.2.3　经验方法25212.2.4　在实践中应用软件度量—常规方法25312.3　工业中实施度量方案的六个关键问题25412.3.1　利益相关者、需求和规划：成功度量方案的基础25412.3.2　度量收集：如何收集、何时收集、谁收集25612.3.3　空有数据，没有信息：当数据不是你所需要或期望的25712.3.4　领域专家的关键作用25912.3.5　顺应不断变化的需求26112.3.6　向用户传达分析结果的有效方法26212.4　结论264参考文献265第13章　在软件工程中使用数据进行决策：为软件健康提供一种分析方法26713.1　引言26713.2　软件工程度量简史26813.3　建立明确的目标26913.3.1　基准27013.3.2　产品目标27113.4　度量评审27113.4.1　上下文度量27313.4.2　约束性度量27413.4.3　开发度量27613.5　软件项目数据分析面临的挑战27813.5.1　数据收集27813.5.2　数据解释28013.6　示例：通过数据的使用改变产品开发28113.7　用数据驱动软件工程过程284参考文献285第14章　基于社区数据进行开源软件使用的风险管理28714.1　引言28714.2　背景28814.2.1　风险和开源软件的基本概念28814.2.2　建模和分析技术29014.3　OSS使用风险管理的一种方法29214.4　OSS社区结构和行为分析：XWiki案例29314.4.1　OSS社区的社交网络分析29414.4.2　软件质量、OSS社区行为和OSS项目的统计分析29414.4.3　通过贝叶斯网络评估风险指标29814.4.4　基于模型对开源软件生态系统建模和推理30014.4.5　整合分析以进行综合风险评估30214.5　一个风险评估的案例：Moodbile案例30314.6　相关工作30814.6.1　OSS社区的数据分析30814.6.2　通过目标导向技术进行风险建模和分析30914.7　结论309致谢310参考文献310第15章　大型企业软件状态评估—12年历程31215.1　引言31215.2　过程和评估的演变31315.3　Avaya软件状态报告的影响31515.4　评估方法和机制31515.5　数据来源31815.5.1　数据精度32015.5.2　分析的数据类型32115.6　分析示例32115.6.1　人员分析32215.6.2　可预测性分析32415.6.3　风险文件管理32515.7　软件开发实践32815.7.1　七个原始的关键软件领域32915.7.2　四个有代表性的跟踪实践33015.7.3　实践领域示例：设计质量33015.7.4　个体实践的示例：静态分析33115.8　评估跟踪：推荐和影响33315.8.1　推荐示例33415.8.2　推荐的部署33515.9　评估的影响33515.9.1　示例：自动化构建管理33515.9.2　示例：风险文件管理的部署33615.9.3　客户质
