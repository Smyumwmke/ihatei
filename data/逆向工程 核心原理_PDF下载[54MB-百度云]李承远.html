逆向工程 核心原理 PDF下载 李承远 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711535018
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711535018
<p>书名:逆向工程 核心原理</p><p>作者:李承远</p><p>页数:679</p><p>定价:¥109.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2014-05-01</p><p>ISBN:9787115350183</p><p><h2>本书特色</h2></p>[<p>
《逆向工程核心原理》十分详尽地介绍了代码逆向分析的核心原理。作者在ahnlab 研究所工作多年，书中不仅包括其以此经验为基础亲自编写的大量代码，还包含了逆向工程研究人员必须了解的各种技术和技巧。彻底理解并切实掌握逆向工程这门技术，就能在众多it相关领域进行拓展运用，这本《逆向工程核心原理》就是通向逆向工程大门的捷径。 
　　想成为逆向工程研究员的读者或正在从事逆向开发工作的开发人员一定会通过《逆向工程核心原理》获得很大帮助。同时，想成为安全领域专家的人也可从《逆向工程核心原理》轻松起步。
                                        </p>]<p><h2>内容简介</h2></p>[<p>书中用到的几乎所有示例都基于作者在逆向分析实践中获得的知识与经验，是其亲自开发的程序，紧扣各章主题，绝无累赘。 
　　作者将培训经验应用到本书的组织结构、内容讲解、示例选择等各方面，以求将较为难懂的技术以更易懂的方式呈现给各位。 
　　作者几年前就开设了一个逆向技术学习博客并运营至今，通过与访问者之间的交流，充分了解了初学者们的困惑和需求。</p>]<p><h2>作者简介</h2></p>[<p>李承远 
　　在AhnLab从事恶意代码分析工作，一直维护着一个逆向分析技术专业学习博客。从接触逆向分析技术开始就为其迷人魅力深深吸引，对逆向分析技术的传播及多领域应用非常关注，喜欢读书、发呆，也向往新的挑战。 
　　武传海 
　　擅韩语，喜计算机，有多年翻译经验，内容涉及多个领域，尤其擅长翻译各类计算机图书，已出版多部韩语译著。 
　　QQ：768160125</p>]<p><h2>目录</h2></p>
    **部分　代码逆向技术基础第1章　关于逆向工程　1.1　逆向工程　1.2　代码逆向工程　1.2.1　逆向分析法　1.2.2　源代码、十六进制代码、汇编代码　1.2.3.“打补丁”与“破解”　1.3　代码逆向准备　1.3.1　目标　1.3.2　激情　1.3.3　谷歌　1.4　学习逆向分析技术的禁忌　1.4.1　贪心　1.4.2　急躁　1.5　逆向分析技术的乐趣　第2章　逆向分析hello.world!程序　2.1　hello.world!程序　2.2　调试helloworld.exe程序　2.2.1　调试目标　2.2.2　开始调试　2.2.3　入口点　2.2.4　跟踪40270c函数　2.2.5　跟踪40104f跳转语句　2.2.6　查找main()函数　2.3　进一步熟悉调试器　2.3.1　调试器指令　2.3.2.“大本营”　2.3.3　设置“大本营”的四种方法　2.4　快速查找指定代码的四种方法　2.4.1　代码执行法　2.4.2　字符串检索法　2.4.3　api检索法(1)：在调用代码中设置断点　2.4.4　api检索法(2)：在api代码中设置断点　2.5　使用“打补丁”方式修改“hello.world!”字符串　2.5.1.“打补丁”　2.5.2　修改字符串的两种方法　2.6　小结　第3章　小端序标记法　3.1　字节序　3.1.1　大端序与小端序　3.1.2　在ollydbg中查看小端序　第4章　ia-32寄存器基本讲解　4.1　什么是cpu寄存器　4.2　ia-32寄存器　4.3　小结　第5章　栈　5.1　栈　5.1.1　栈的特征　5.1.2　栈操作示例　第6章　分析abex’.crackme#1　6.1　abex’.crackme.#1　6.1.1　开始调试　6.1.2　分析代码　6.2　破解　6.3　将参数压入栈　6.4　小结　第7章　栈帧　7.1　栈帧　7.2　调试示例：stackframe.exe　7.2.1　stackframe.cpp　7.2.2　开始执行main()函数&生成栈帧　7.2.3　设置局部变量　7.2.4　add()函数参数传递与调用　7.2.5　开始执行add()函数&生成栈帧　7.2.6　设置add()函数的局部变量(x,.y)　7.2.7　add运算　7.2.8　删除函数add()的栈帧&函数执行完毕(返回)　7.2.9　从栈中删除函数add()的参数(整理栈)　7.2.10　调用printf()函数　7.2.11　设置返回值　7.2.12　删除栈帧&main()函数终止　7.3　设置ollydbg选项　7.3.1　disasm选项　7.3.2　analysis1选项　7.4　小结　第8章　abex’.crackme.#2　8.1　运行abex’.crackme.#2　8.2　visual.basic文件的特征　8.2.1　vb专用引擎　8.2.2　本地代码和伪代码　8.2.3　事件处理程序　8.2.4　未文档化的结构体　8.3　开始调试　8.3.1　间接调用　8.3.2　rt_mainstruct结构体　8.3.3　thunrtmain()函数　8.4　分析crackme　8.4.1　检索字符串　8.4.2　查找字符串地址　8.4.3　生成serial的算法　8.4.4　预测代码　8.4.5　读取name字符串的代码　8.4.6　加密循环　8.4.7　加密方法　8.5　小结　第9章　process.explorer——*优秀的进程管理工具　9.1　process.explorer　9.2　具体有哪些优点呢　9.3　sysinternals　第10章　函数调用约定　10.1　函数调用约定　10.1.1　cdecl　10.1.2　stdcall　10.1.3　fastcall　第11章　视频讲座　11.1　运行　11.2　分析　11.2.1　目标(1)：去除消息框　11.2.2　打补丁(1)：去除消息框　11.2.3　目标(2)：查找注册码　11.3　小结　第12章　究竟应当如何学习代码逆向分析　12.1　逆向工程　12.1.1　任何学习都应当有目标　12.1.2　拥有积极心态　12.1.3　要感受其中的乐趣　12.1.4　让检索成为日常生活的一部分　12.1.5　*重要的是实践　12.1.6　请保持平和的心态　第二部分　pe文件格式第13章　pe文件格式　13.1　介绍　13.2　pe文件格式　13.2.1　基本结构　13.2.2　va&rva　13.3　pe头　13.3.1　dos头　13.3.2　dos存根　13.3.3　nt头　13.3.4　nt头：文件头　13.3.5　nt头：可选头　13.3.6　节区头　13.4　rva.to.raw　13.5　iat　13.5.1　dll　13.5.2　image_import_descriptor　13.5.3　使用notepad.exe练习　13.6　eat　13.6.1　image_export_directory　13.6.2　使用kernel32.dll练习　13.7　高级pe　13.7.1　peview.exe　13.7.2　patched.pe　13.8　小结　第14章　运行时压缩　14.1　数据压缩　14.1.1　无损压缩　14.1.2　有损压缩　14.2　运行时压缩器　14.2.1　压缩器　14.2.2　保护器　14.3　运行时压缩测试　第15章　调试upx压缩的notepad程序　15.1　notepad.exe的ep代码　15.2　notepad_upx.exe的ep代码　15.3　跟踪upx文件　15.3.1　ollydbg的跟踪命令　15.3.2　循环.#1　15.3.3　循环.#2　15.3.4　循环.#3　15.3.5　循环.#4　15.4　快速查找upx.oep的方法　15.4.1　在popad指令后的jmp指令处设置断点　15.4.2　在栈中设置硬件断点　15.5　小结　第16章　基址重定位表　16.1　pe重定位　16.1.1　dll/sys　16.1.2　exe　16.2　pe重定位时执行的操作　16.3　pe重定位操作原理　16.3.1　基址重定位表　16.3.2　image_base_relocation结构体　16.3.3　基址重定位表的分析方法　16.3.4　练习　第17章　从可执行文件中删除.reloc节区　17.1　.reloc节区　17.2　reloc.exe　17.2.1　删除.reloc节区头　17.2.2　删除.reloc节区　17.2.3　修改image_file_header　17.2.4　修改image_optional_header　17.3　小结　第18章　upack.pe文件头详细分析　18.1　upack说明　18.2　使用upack压缩notepad.exe　18.3　使用stud_pe工具　18.4　比较pe文件头　18.4.1　原notepad.exe的pe文件头　18.4.2　notepad_upack.exe运行时压缩的pe文件头　18.5　分析upack的pe文件头　18.5.1　重叠文件头　18.5.2　image_file_header.sizeofoptionalheader　18.5.3　image_optional_header.numberof-rvaandsizes　18.5.4　image_section_header　18.5.5　重叠节区　18.5.6　rva.to.raw　18.5.7　导入表(image_import_descriptor.array)　18.5.8　导入地址表　18.6　小结　第19章　upack调试?.查找oep　19.1　ollydbg运行错误　19.2　解码循环　19.3　设置iat　19.4　小结　第20章　“内嵌补丁”练习　20.1　内嵌补丁　20.2　练习：patchme　20.3　调试：查看代码流　20.4　代码结构　20.5.“内嵌补丁”练习　20.5.1　补丁代码要设置在何处呢　20.5.2　制作补丁代码　20.5.3　执行补丁代码　20.5.4　结果确认　第三部分　dll注入第21章　windows消息钩取　21.1　钩子　21.2　消息钩子　21.3　setwindowshookex()　21.4　键盘消息钩取练习　21.4.1　练习示例hookmain.exe　21.4.2　分析源代码　21.5　调试练习　21.5.1　调试hookmain.exe　21.5.2　调试notepad.exe进程内的keyhook.dll　21.6　小结　第22章　恶意键盘记录器　22.1　恶意键盘记录器的目标　22.1.1　在线游戏　22.1.2　网上银行　22.1.3　商业机密泄露　22.2　键盘记录器的种类与发展趋势　22.3　防范恶意键盘记录器　22.4　个人信息　第23章　dll注入　23.1　dll注入　23.2　dll注入示例　23.2.1　改善功能与修复bug　23.2.2　消息钩取　23.2.3　api钩取　23.2.4　其他应用程序　23.2.5　恶意代码　23.3　dll注入的实现方法　23.4　createremotethread()　23.4.1　练习示例myhack.dll　23.4.2　分析示例源代码　23.4.3　调试方法　23.5　appinit_dlls　23.5.1　分析示例源码　23.5.2　练习示例myhack2.dll　23.6　setwindowshookex()　23.7　小结　第24章　dll卸载　24.1　dll卸载的工作原理　24.2　实现dll卸载　24.2.1　获取进程中加载的dll信息　24.2.2　获取目标进程的句柄　24.2.3　获取freelibrary().api地址　24.2.4　在目标进程中运行线程　24.3　dll卸载练习　24.3.1　复制文件及运行notepad.exe　24.3.2　注入myhack.dll　24.3.3　卸载myhack.dll　第25章　通过修改pe加载dll　25.1　练习文件　25.1.1　textview.exe　25.1.2　textview_patched.exe　25.2　源代码.-.myhack3.cpp　25.2.1　dllmain()　25.2.2　downloadurl()　25.2.3　dropfile()　25.2.4　dummy()　25.3　修改textview.exe文件的准备工作　25.3.1　修改思路　25.3.2　查看idt是否有足够空间　25.3.3　移动idt　25.4　修改textview.exe　25.4.1　修改导入表的rva值　25.4.2　删除绑定导入表　25.4.3　创建新idt　25.4.4　设置name、int、iat　25.4.5　修改iat节区的属性值　25.5　检测验证　25.6　小结　第26章　pe.tools　26.1　pe.tools　26.1.1　进程内存转储　26.1.2　pe编辑器　26.2　小结　第27章　代码注入　27.1　代码注入　27.2　dll注入与代码注入　27.3　练习示例　27.3.1　运行notepad.exe　27.3.2　运行codeinjection.exe　27.3.3　弹出消息框　27.4　codeinjection.cpp　27.4.1　main()函数　27.4.2　threadproc()函数　27.4.3　injectcode()函数　27.5　代码注入调试练习　27.5.1　调试notepad.exe　27.5.2　设置ollydbg选项　27.5.3　运行codeinjection.exe　27.5.4　线程开始代码　27.6　小结　第28章　使用汇编语言编写注入代码　28.1　目标　28.2　汇编编程　28.3　ollydbg的汇编命令　28.3.1　编写threadproc()函数　28.3.2　保存文件　28.4　编写代码注入程序　28.4.1　获取threadproc()函数的二进制代码　28.4.2　codeinjection2.cpp　28.5　调试练习　28.5.1　调试notepad.exe　28.5.2　设置ollydbg选项　28.5.3　运行codeinjection2.exe　28.5.4　线程起始代码　28.6　详细分析　28.6.1　生成栈帧　28.6.2　thread_param结构体指针　28.6.3.“user32.dll”字符串　28.6.4　压入“user32.dll”字符串参数　28.6.5　调用loadlibrarya(“user32.dll”)　28.6.6.“messageboxa”字符串　28.6.7　调用getprocaddress(hmod,“messageboxa”)　28.6.8　压入messageboxa()函数的参数.1.-mb_ok　28.6.9　压入messageboxa()函数的参数.2.-“reversecore”　28.6.10　压入messageboxa()函数的参数.3.-“www.reversecore.com”　28.6.11　压入messageboxa()函数的参数.4.-null　28.6.12　调用messageboxa()　28.6.13　设置threadproc()函数的返回值　28.6.14　删除栈帧及函数返回　28.7　小结　第四部分　api钩取第29章　api钩取：逆向分析之“花”　29.1　钩取　29.2　api是什么　29.3　api钩取　29.3.1　正常调用api　29.3.2　钩取api调用　29.4　技术图表　29.4.1　方法对象(是什么)　29.4.2　位置(何处)　29.4.3　技术(如何)　29.4.4　api　第30章　记事本writefile().api钩取　30.1　技术图表—调试技术　30.2　关于调试器的说明　30.2.1　术语　30.2.2　调试器功能　30.2.3　调试器的工作原理　30.2.4　调试事件　30.3　调试技术流程　30.4　练习　30.5　工作原理　30.5.1　栈　30.5.2　执行流　30.5.3.“脱钩”&“钩子”　30.6　源代码分析　30.6.1　main()　30.6.2　debugloop()　30.6.3　exit_process_debug_event　30.6.4　create_process_debug_event-oncreateprocess-debugevent()　30.6.5　exception_debug_event-onexception-debugevent()　第31章　关于调试器　31.1　ollydbg　31.2　ida.pro　31.3　windbg　第32章　计算器显示中文数字　32.1　技术图表　32.2　选定目标api　32.3　iat钩取工作原理　32.4　练习示例　32.5　源代码分析　32.5.1　dllmain()　32.5.2　mysetwindowtextw()　32.5.3　hook_iat()　32.6　调试被注入的dll文件　32.6.1　dllmain()　32.6.2　hook_iat()　32.6.3　mysetwindowtextw()　32.7　小结　第33章　隐藏进程　33.1　技术图表　33.2　api代码修改技术的原理　33.2.1　钩取之前　33.2.2　钩取之后　33.3　进程隐藏　33.3.1　进程隐藏工作原理　33.3.2　相关api　33.3.3　隐藏技术的问题　33.4　练习.#1(hideproc.exe，stealth.dll)　33.4.1　运行notepad.exe、procexp.exe、taskmgr.exe　33.4.2　运行hideproc.exe　33.4.3　确认stealth.dll注入成功　33.4.4　查看notepad.exe进程是否隐藏成功　33.4.5　取消notepad.exe进程隐藏　33.5　源代码分析　33.5.1　hideproc.cpp　33.5.2　stealth.cpp　33.6　全局api钩取　33.6.1　kernel32.createprocess().api　33.6.2　ntdll.zwresumethread().api　33.7　练习#2(hideproc2.exe,stealth2.dll)　33.7.1　复制stealth2.dll文件到%system%文件夹中　33.7.2　运行hideproc2.exe.-hide　33.7.3　运行procexp.exe?epad.exe　33.7.4　运行hideproc2.exe.-show　33.8　源代码分析　33.8.1　hideproc2.cpp　33.8.2　stealth2.cpp　33.9　利用“热补丁”技术钩取api　33.9.1　api代码修改技术的问题　33.9.2.“热补丁”(修改7个字节代码)　33.10　练习.#3：stealth3.dll　33.11　源代码分析　33.12　使用“热补丁”api钩取技术时需要考虑的问题　33.13　小结　第34章　高级全局api钩取：ie连接控制　34.1　目标api　34.2　ie进程结构　34.3　关于全局api钩取的概念　34.3.1　常规api钩取　34.3.2　全局api钩取　34.4　ntdll!zwresumethread().api　34.5　练习示例：控制ie网络连接　34.5.1　运行ie　34.5.2　注入dll　34.5.3　创建新选项卡　34.5.4　尝试连接网站　34.5.5　卸载dll　34.5.6　课外练习　34.6　示例源代码　34.6.1　dllmain()　34.6.2　newinternetconnectw()　34.6.3　newzwresumethread()　34.7　小结　第35章　优秀分析工具的五种标准　35.1　工具　35.2　代码逆向分析工程师　35.3　优秀分析工具的五种标准　35.3.1　精简工具数量　35.3.2　工具功能简单、使用方便　35.3.3　完全掌握各种功能　35.3.4　不断升级更新　35.3.5　理解工具的核心工作原理　35.4　熟练程度的重要性　第五部分　64位&windows内核第36章　64位计算　36.1　64位计算环境　36.1.1　64位cpu　36.1.2　64位os　36.1.3　win32.api　36.1.4　wow64　36.1.5　练习：wow64test　36.2　编译64位文件　36.2.1　microsoft.windows.sdk(software.development.kit)　36.2.2　设置visual.c++.2010.express环境　第37章　x64处理器　37.1　x64中新增或变更的项目　37.1.1　64位　37.1.2　内存　37.1.3　通用寄存器　37.1.4　call/jmp指令　37.1.5　函数调用约定　37.1.6　栈.&.栈帧　37.2　练习：stack32.exe.&.stack64.exe　37.2.1　stack32.exe　37.2.2　stack64.exe　37.3　小结　第38章　pe32+　38.1　pe32+(pe+、pe64)　38.1.1　image_nt_headers　38.1.2　image_file_header　38.1.3　image_optional_header　38.1.4　image_thunk_data　38.1.5　image_tls_directory　第39章　windbg　39.1　windbg　39.1.1　windbg的特征　39.1.2　运行windbg　39.1.3　内核调试　39.1.4　windbg基本指令　第40章　64位调试　40.1　x64环境下的调试器　40.2　64位调试　40.3　pe32：wow64test_x86.exe　40.3.1　ep代码　40.3.2　startup代码　40.3.3　main()函数　40.4　pe32+：wow64test_x64.exe　40.4.1　系统断点　40.4.2　ep代码　40.4.3　startup代码　40.4.4　main()函数　40.5　小结　第41章　aslr　41.1　windows内核版本　41.2　aslr　41.3　visual.c++　41.4　aslr.exe　41.4.1　节区信息　41.4.2　image_file_headercharacteristics　41.4.3　image_optional_headerdll.characteristics　41.5　练习：删除aslr功能　第42章　内核6中的会话　42.1　会话　42.2　会话0隔离机制　42.3　增强安全性　第43章　内核6中的dll注入　43.1　再现dll注入失败　43.1.1　源代码　43.1.2　注入测试　43.2　原因分析　43.2.1　调试.#1　43.2.2　调试.#2　43.3　练习：使createremotethread()正常工作　43.3.1　方法.#1：修改createsuspended参数值　43.3.2　方法.#2：操纵条件分支　43.4　稍作整理　43.5　injectdll_new.exe　43.5.1　injectdll_new.cpp　43.5.2　注入练习　第44章　injdll.exe：dll注入专用工具　44.1　injdll.exe　44.1.1　使用方法　44.1.2　使用示例　44.1.3　注意事项　第六部分　高级逆向分析技术第45章　tls回调函数　45.1　练习.#1：hellotls.exe　45.2　tls　45.2.1　image_data_directory[9]　45.2.2　image_tls_directory　45.2.3　回调函数地址数组　45.3　tls回调函数　45.4　练习.#2：tlstest.exe　45.4.1　dll_process_attach　45.4.2　dll_thread_attach　45.4.3　dll_thread_detach　45.4.4　dll_process_detach　45.5　调试tls回调函数　45.6　手工添加tls回调函数　45.6.1　修改前的原程序　45.6.2　设计规划　45.6.3　编辑pe文件头　45.6.4　设置image_tls_directory结构体　45.6.5　编写tls回调函数　45.6.6　*终完成　45.7　小结　第46章　teb　46.1　teb　46.1.1　teb结构体的定义　46.1.2　teb结构体成员　46.1.3　重要成员　46.2　teb访问方法　46.2.1　ntdll.ntcurrentteb()　46.2.2　fs段寄存器　46.3　小结　第47章　peb　47.1　peb　47.1.1　peb访问方法　47.1.2　peb结构体的定义　47.1.3　peb结构体的成员　47.2　peb的重要成员　47.2.1　peb.beingdebugged　47.2.2　peb.imagebaseaddress　47.2.3　peb.ldr　47.2.4　peb.processheap.&.peb.ntglobalflag　47.3　小结　第48章　seh　48.1　seh　48.2　seh练习示例.#1　48.2.1　正常运行　48.2.2　调试运行　48.3　os的异常处理方法　48.3.1　正常运行时的异常处理方法　48.3.2　调试运行时的异常处理方法　48.4　异常　48.4.1　exception_access_violation(c0000005)　48.4.2　exception_breakpoint(80000003)　48.4.3　exception_illegal_instruction(c000001d)　48.4.4　exception_int_divide_by_zero(c0000094)　48.4.5　exception_single_step(80000004)　48.5　seh详细说明　48.5.1　seh链　48.5.2　异常处理函数的定义　48.5.3　teb.nttib.exceptionlist　48.5.4　seh安装方法　48.6　seh练习示例.#2(seh.exe)　48.6.1　查看seh链　48.6.2　添加seh　48.6.3　发生异常　48.6.4　查看异常处理器参数　48.6.5　调试异常处理器　48.6.6　删除seh　48.7　设置ollydbg选项　48.7.1　忽略kernel32中发生的内存非法访问异常　48.7.2　向被调试者派送异常　48.7.3　其他异常处理　48.7.4　简单练习　48.8　小结　第49章　ia-32指令　49.1　ia-32指令　49.2　常用术语　49.2.1　反汇编器　49.2.2　反编译器　49.2.3　反编译简介　49.3　ia-32指令格式　49.3.1　指令前缀　49.3.2　操作码　49.3.3　modr/m　49.3.4　sib　49.3.5　位移　49.3.6　立即数　49.4　指令解析手册　49.4.1　下载ia-32用户手册　49.4.2　打印指令解析手册　49.5　指令解析练习　49.5.1　操作码映射　49.5.2　操作数　49.5.3　modr/m　49.5.4　group　49.5.5　前缀　49.5.6　双字节操作码　49.5.7　移位值&立即数　49.5.8　sib　49.6　指令解析课外练习　49.7　小结　第七部分　反调试技术第50章　反调试技术　50.1　反调试技术　50.1.1　依赖性　50.1.2　多种反调试技术　50.2　反调试破解技术　50.3　反调试技术的分类　50.3.1　静态反调试技术　50.3.2　动态反调试技术　第51章　静态反调试技术　51.1　静态反调试的目的　51.2　peb　51.2.1　beingdebugged(+0x2)　51.2.2　ldr(+0xc)　51.2.3　process.heap(+0x18)　51.2.4　ntglobalflag(+0x68)　51.2.5　练习：?staad_peb.exe　51.2.6　破解之法　51.3　ntqueryinformationprocess()　51.3.1　processdebugport(0x7)　51.3.2　processdebugobjecthandle(0x1e)　51.3.3　processdebugflags(0x1f)　51.3.4　练习：staad_ntqip.exe　51.3.5　破解之法　51.4　ntquerysysteminformation()　51.4.1　systemkerneldebugger-information(0x23)　51.4.2　练习：staad_ntqsi.exe　51.4.3　破解之法　51.5　ntqueryobject()　51.6　zwsetinformationthread()　51.6.1　练习：staad_zwsit.exe　51.6.2　破解之法　51.7　tls回调函数　51.8　etc　51.8.1　练习：staad_findwindow.exe　51.8.2　破解之法　51.9　小结　第52章　动态反调试技术　52.1　动态反调试技术的目的　52.2　异常　52.2.1　seh　52.2.2　setunhandledexception-filter()　52.3　timing.check　52.3.1　时间间隔测量法　52.3.2　rdtsc　52.4　陷阱标志　52.4.1　单步执行　52.4.2　int.2d　52.5　0xcc探测　52.5.1　api断点　52.5.2　比较校验和　第53章　高级反调试技术　53.1　高级反调试技术　53.2　垃圾代码　53.3　扰乱代码对齐　53.4　加密/解密　53.4.1　简单的解码示例　53.4.2　复杂的解码示例　53.4.3　特殊情况：代码重组　53.5　stolen.bytes(remove.oep)　53.6　api重定向　53.6.1　原代码　53.6.2　api重定向示例.#1　53.6.3　api重定向示例#2　53.7　debug.blocker(self.debugging)　53.8　小结　第八部分　调试练习第54章　调试练习1：服务　54.1　服务进程的工作原理　54.1.1　服务控制器　54.1.2　服务启动过程　54.2　debugme1.exe示例讲解　54.2.1　安装服务　54.2.2　启动服务　54.2.3　源代码　54.3　服务进程的调试　54.3.1　问题在于scm　54.3.2　调试器无所不能　54.3.3　常用方法　54.4　服务调试练习　54.4.1　直接调试：强制设置eip　54.4.2　服务调试的常用方法：“附加”方式　54.5　小结　第55章　调试练习2：自我创建　55.1　自我创建　55.2　工作原理　55.2.1　创建子进程(挂起模式)　55.2.2　更改eip　55.2.3　恢复主线程　55.3　示例程序源代码　55.4　调试练习　55.4.1　需要考虑的事项　55.4.2　jit调试　55.4.3　debugme2.exe　55.5　小结　第56章　调试练习3：pe映像切换　56.1　pe映像　56.2　pe映像切换　56.3　示例程序：fake.exe、real.exe、debugme3.exe　56.4　调试1　56.4.1　open?.输入运行参数　56.4.2　main()函数　56.4.3　subfunc_1()　56.4.4　createprocess(“fake.exe”，create_suspended)　56.4.5　subfunc_2()　56.4.6　subfunc_3()　56.4.7　resumethread()　56.5　调试2　56.5.1　思考　56.5.2　向ep设置无限循环　56.6　小结　第57章　调试练习4：debug.blocker　57.1　debug.blocker　57.2　反调试特征　57.2.1　父与子的关系　57.2.2　被调试进程不能再被其他调试器调试　57.2.3　终止调试进程的同时也终止被调试进程　57.2.4　调试器操作被调试者的代码　57.2.5　调试器处理被调试进程中发生的异常　57.3　调试练习：debugme4.exe　57.4　**次调试　57.4.1　选定调试的起始位置　57.4.2　main()　57.5　第二次调试　57.6　第三次调试　57.7　第四次调试　57.8　第五次调试　57.8.1　系统断点　57.8.2　exception_illegal_instruction(1)　57.8.3　exception_illegal_instruction(2)　57.9　第六次调试　57.9.1　40121d(**个异常)　57.9.2　401299(第二个异常)　57.10　第七次调试　57.10.1　静态方法　57.10.2　动态方法　57.11　小结　结束语　索引
