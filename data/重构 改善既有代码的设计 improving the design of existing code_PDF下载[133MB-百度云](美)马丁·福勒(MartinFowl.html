重构:改善既有代码的设计:improving the design of existing code PDF下载 (美)马丁·福勒(MartinFowl 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711550864
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711550864
<p>书名:重构:改善既有代码的设计:improving the design of existing code</p><p>作者:(美)马丁·福勒(Martin Fowl</p><p>页数:421页</p><p>定价:¥168.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2019-04-01</p><p>ISBN:9787115508645</p><p><h2>本书特色</h2></p>[<p>
《重构 改善既有代码的设计 第2版 全彩精装版》是经典著作《重构》出版20年后的更新版。书中清晰揭示了重构的过程，解释了重构的原理和*实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。书中给出了60多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。本书提出的重构准则将帮助开发人员一次一小步地修改代码，从而减少了开发过程中的风险。
《重构 改善既有代码的设计 第2版 全彩精装版》适合软件开发人员、项目管理人员等阅读，也可作为高等院校计算机及相关专业师生的参考读物。
                                        </p>]<p><h2>内容简介</h2></p>[<p>1. 世界软件开发大师的不朽经典 
2. 生动阐述重构原理和具体做法　　　 
3. 普通程序员进阶到编程高手必须修炼的秘笈
4. 全彩印刷，精装版本，更适合案头常备
重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。20 多年前，正是《重构：改善既有代码的设计》第1 版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。如今，Martin Fowler 的《重构：改善既有代码的设计》一书已经成为全球有经验的程序员手中的利器，既可用来改善既有代码的设计、提升软件的可维护性，又可用于使既有代码更易理解、焕发出新的活力。
这本备受关注的第2 版在第1 版的基础上做了全面修订，反映了编程领域业已发生的许多变化。第2 版中介绍的重构列表更加内聚，并用JavaScript 语言重写了代码范例。此外，第2 版中还新增了与函数式编程相关的重构范例，旨在教会读者如何在没有类的环境下开展重构。
新版沿袭了第1 版的结构，依次解释什么是重构，为什么要重构，如何通过“坏味道”识别出需要重构的代码，以及如何在实践中成功实施重构（无论用的是什么编程语言）。
● 理解重构的过程和重构的基本原则；
● 快速有效地应用各种重构手法，提升程序的表达力和可维护性；
● 识别代码中能指示出需要重构的地方的“坏味道”；
● 深入了解各种重构手法，每个手法都包含解释、动机、做法和范例4 个部分；
● 构建稳固的测试，以支持重构工作的开展；
● 理解重构过程的权衡取舍以及重构存在的挑战等。
本书凝聚了软件开发社区专家多年摸索而获得的宝贵经验，书中所蕴涵的思想和精华，值得反复咀嚼，而且往往能够常读常新。 </p>]<p><h2>作者简介</h2></p>[<p>作者简介
马丁·福勒（Martin Fowler） 世界软件开发大师，ThoughtWorks 首席科学家。他是一位作家、演说者、咨询师和泛软件开发领域的意见领袖。他致力于改善企业级的软件设计，对优秀的设计以及支撑优秀设计的工程实践孜孜以求。他在重构、面向对象分析设计、模式、XP 和UML 等领域都有卓越贡献，著有《重构》《分析模式》《领域特定语言》等经典著作。 
译者简介
熊节　在IT 行业已经打拼了18年，在金融、零售、政府、电信、制造业等行业的信息化建设方面有着丰富经验，是中国IT业敏捷浪潮的领军人物。熊节拥有利物浦大学MBA学位。
林从羽　ThoughtWorks软件开发工程师，曾服务于国内外多家大型企业，致力于为团队更快更好地交付可工作的软件。拥抱敏捷精神，TDD爱好者，纯键盘工作者。</p>]<p><h2>目录</h2></p>
    第 1 章　重构，第 一个示例  1
1.1　起点　1
1.2　对此起始程序的评价　3
1.3　重构的第 一步　5
1.4　分解statement 函数　6
1.5　进展：大量嵌套函数　22
1.6　拆分计算阶段与格式化阶段　24
1.7　进展：分离到两个文件（和两个阶段）　31
1.8　按类型重组计算过程　34
1.9　进展：使用多态计算器来提供数据　41
1.10　结语　43
第　2 章 重构的原则　45
2.1　何谓重构　45
2.2　两顶帽子　46
2.3　为何重构　47
2.4　何时重构　50
2.5　重构的挑战　55
2.6　重构、架构和YAGNI　62
2.7　重构与软件开发过程　63
2.8　重构与性能　64
2.9　重构起源何处　67
2.10　自动化重构　68
2.11　延展阅读　70
第3　章 代码的坏味道　71
3.1　神秘命名（Mysterious Name）　72
3.2　重复代码（Duplicated Code）　72
3.3　过长函数（Long Function）　73
3.4　过长参数列表（Long Parameter List）　74
3.5　全局数据（Global Data）　74
3.6　可变数据（Mutable Data）　75
3.7　发散式变化（Divergent Change）　76
3.8　霰弹式修改（Shotgun Surgery）　76
3.9　依恋情结（Feature Envy）　77
3.10　数据泥团（Data Clumps）　78
3.11　基本类型偏执（Primitive Obsession）　78
3.12　重复的switch（Repeated Switches）　79
3.13　循环语句（Loops）　79
3.14　冗赘的元素（Lazy Element）　80
3.15　夸夸其谈通用性（Speculative Generality）　80
3.16　临时字段（Temporary Field）　80
3.17　过长的消息链（Message Chains）　81
3.18　中间人（Middle Man）　81
3.19　内幕交易（Insider Trading）　82
3.20　过大的类（Large Class）　82
3.21　异曲同工的类（Alternative Classes with Different Interfaces）　83
3.22　纯数据类（Data Class）　83
3.23　被拒绝的遗赠（Refused Bequest）　83
3.24　注释（Comments）　84
第4　章 构筑测试体系　85
4.1　自测试代码的价值　85
4.2　待测试的示例代码　87
4.3　第 一个测试　90
4.4　再添加一个测试　93
4.5　修改测试夹具　95
4.6　探测边界条件　96
4.7　测试远不止如此　99
第5　章 介绍重构名录　101
5.1　重构的记录格式　101
5.2　挑选重构的依据　102
第6　章 第 一组重构　105
6.1　提炼函数（Extract Function）　106
6.2　内联函数（Inline Function）　115
6.3　提炼变量（Extract Variable）　119
6.4　内联变量（Inline Variable）　123
6.5　改变函数声明（Change Function Declaration）　124
6.6　封装变量（Encapsulate Variable）　132
6.7　变量改名（Rename Variable）　137
6.8　引入参数对象（Introduce Parameter Object）　140
6.9　函数组合成类（Combine Functions into Class）　144
6.10　函数组合成变换（Combine Functions into Transform）　149
6.11　拆分阶段（Split Phase）　154
第7　章 封装　161
7.1　封装记录（Encapsulate Record）　162
7.2　封装集合（Encapsulate Collection）　170
7.3　以对象取代基本类型（Replace Primitive with Object）　174
7.4　以查询取代临时变量（Replace Temp with Query）　178
7.5　提炼类（Extract Class）　182
7.6　内联类（Inline Class）　186
7.7　隐藏委托关系（Hide Delegate）　189
7.8　移除中间人（Remove Middle Man）　192
7.9　替换算法（Substitute Algorithm）　195
第8　章 搬移特性　197
8.1　搬移函数　198
8.2　搬移字段（Move Field）　207
8.3　搬移语句到函数（Move Statements into Function）　213
8.4　搬移语句到调用者（Move Statements to Callers）　217
8.5　以函数调用取代内联代码（Replace Inline Code with Function Call）　222
8.6　移动语句（Slide Statements）　223
8.7　拆分循环（Split Loop）　227
8.8　以管道取代循环（Replace Loop with Pipeline）　231
8.9　移除死代码（Remove Dead Code）　237
第9　章 重新组织数据　239
9.1　拆分变量（Split Variable）　240
9.2　字段改名（Rename Field）　244
9.3　以查询取代派生变量（Replace Derived Variable with Query）　248
9.4　将引用对象改为值对象（Change Reference to Value）　252
9.5　将值对象改为引用对象（Change Value to Reference）　256
第　10 章 简化条件逻辑　259
10.1　分解条件表达式（Decompose Conditional）　260
10.2　合并条件表达式（Consolidate Conditional Expression）　263
10.3　以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）　266
10.4　以多态取代条件表达式（Replace Conditional with Polymorphism）　272
10.5　引入特例（Introduce Special Case）　289
10.6　引入断言（Introduce Assertion）　302
第　11 章 重构API　305
11.1　将查询函数和修改函数分离（Separate Query from Modifier）　306
11.2　函数参数化（Parameterize Function）　310
11.3　移除标记参数（Remove Flag Argument）　314
11.4　保持对象完整（Preserve Whole Object）　319
11.5　以查询取代参数（Replace Parameter with Query）　324
11.6　以参数取代查询（Replace Query with Parameter）　327
11.7　移除设值函数（Remove Setting Method）　331
11.8　以工厂函数取代构造函数（Replace Constructor with Factory Function）　334
11.9　以命令取代函数（Replace Function with Command）　337
11.10　以函数取代命令（Replace Command with Function）　344
第　12 章 处理继承关系　349
12.1　函数上移（Pull Up Method）　350
12.2　字段上移（Pull Up Field）　353
12.3　构造函数本体上移（Pull Up Constructor Body）　355
12.4　函数下移（Push Down Method）　359
12.5　字段下移（Push Down Field）　361
12.6　以子类取代类型码（Replace Type Code with Subclasses）　362
12.7　移除子类（Remove Subclass）　369
12.8　提炼超类（Extract Superclass）　375
12.9　折叠继承体系（Collapse Hierarchy）　380
12.10　以委托取代子类（Replace Subclass with Delegate）　381
12.11　以委托取代超类（Replace Superclass with Delegate）　399
参考文献　405
索引　409
