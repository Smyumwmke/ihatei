计算机组成与设计:硬件/软件接口(原书第5版·RISC-V版) PDF下载 戴维 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711165214
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711165214
<p>书名:计算机组成与设计:硬件/软件接口(原书第5版·RISC-V版)</p><p>作者:戴维</p><p>页数:488</p><p>定价:¥169.0</p><p>出版社:机械工业出版社</p><p>出版日期:2020-06-01</p><p>ISBN:9787111652144</p><p><h2>相关资料</h2></p>[<p>在广大计算机程序员和工程师中，几乎没有人不知道Patterson和Hennessy的大作，而今RISC-V版的推出，再次点燃了大家的热情。RISC-V作为一种开源体系结构，从*初用于支持科研和教学，到现在已发展为产业标准的指令集。正在和即将阅读本书的年轻人，你们不仅能够从先行者的智慧中理解RISC-V的精髓，而且有望创建自己的RISC-V内核，为广阔的开源硬件和软件生态系统贡献力量。<br/>—— Krste Asanovi?，RISC-V基金会主席
<br/>教材的选择往往是一个令人沮丧的妥协过程——教学方法的适用度、知识点的覆盖范围、文辞的流畅性、内容的严谨度、成本的高低等都需要考虑。本书之所以是难得一见的好书，正是因为它能满足各个方面的要求，不再需要任何妥协。这不仅是一部关于计算机组成的教科书，也是所有计算机科学教科书的典范。<br/>—— Michael Goldweber，Xavier University
<br/>无论是对于80后、90后还是00后，这都是一本应该珍藏在书架上（或iPad中）的计算机体系结构教材。这本书既古老又新颖，不仅介绍了那些伟大的原理——摩尔定律、抽象、加速经常性事件、冗余、存储层次、并行和流水线，而且使用现代设计对这些伟大原理进行了说明。<br/>—— Mark D. Hill, University of Wisconsin-Madison
<br/>本书不仅讲解计算机体系结构，而且为读者准备了迎接新的变化与挑战的“锦囊”。目前，半导体工艺技术按比例缩小的困难使得所有系统功率受限，而移动系统和大数据处理的性能需求却仍在不断增长。在计算技术的新时代，必须进行软硬件协同设计，并且系统级体系结构优化与部件级优化一样重要。<br/>—— Christos Kozyrakis, Stanford University
<br/>Patterson和Hennessy讨论了不断变化的计算机硬件体系结构中的重要议题，强调硬件和软件模块在不同抽象层次上的交互。书中涵盖各种硬件和软件机制，I/O和并行的概念贯穿其中，全景式呈现了后PC时代的计算机体系结构。无论是平板电脑硬件工程师还是云计算软件架构师，如果你正对能源效率和并行化问题一筹莫展，那么本书必将成为不二之选。<br/>—— Jae C. Oh, Syracuse University</p>]<p><h2>本书特色</h2></p>[<p>
本书由2017年图灵奖得主Patterson和Hennessy共同撰写，是计算机体系结构领域的经典书籍，强调软硬件协同设计及其对性能的影响。本书采用开源的RISC-V指令系统体系结构, 讲解硬件技术、汇编语言、算术运算、流水线、存储层次、I/O以及并行处理器。新内容涵盖平板电脑、云基础设施、ARM（移动计算设备）以及x86（云计算）体系结构，新实例包括Intel Core i7、ARM Cortex-A53以及NVIDIA Fermi GPU。本书适合计算机体系结构领域的专业技术人员参考，也适合高等院校计算机相关专业的学生阅读。
                                        </p>]<p><h2>内容简介</h2></p>[<p>
本书是经典著作《计算机组成与设计》继MIPS版、ARM版之后的*版本，这一版全面切换至RISC-V（64位），精选并讲解其核心指令，同时结合“硬件/软件接口”和“详细阐述”等模块，为不同基础和侧重的读者铺设了深入研究的路径，是Patterson和Hennessy的又一力作。
紧跟后PC时代的发展浪潮，关注并行技术，新内容涵盖平板电脑、云基础设施、ARM（移动计算设备）以及x86（云计算）体系结构，新实例包括Intel Core i7、ARM Cortex-A53以及NVIDIA Fermi GPU。
新增矩阵乘法实例，随着章节推进不断“加速”程序，分别采用子字并行、指令级并行、cache分块技术和线程级并行，仅增加24行代码便使性能翻了200倍，直观呈现出硬件对提高能效的重要性。
强调计算机体系结构中的8个伟大思想：并行，流水线，预测，摩尔定律，存储层次，抽象，加速经常性事件，可靠性。对这些思想的应用贯穿全书，引用总数约100次，反映了技术精髓所在。
 </p>]<p><h2>作者简介</h2></p>[<p>作者简介<br/>戴维·A. 帕特森（David A. Patterson） <br/>Patterson与Hennessy共同荣获了2017年度“图灵奖”，以表彰他们在计算机体系结构领域的开创性贡献。Patterson现为Google杰出工程师，之前为加州大学伯克利分校教授。他曾任ACM主席一职，目前是ACM和IEEE会士，美国艺术与科学院和计算机历史博物馆院士，并入选了美国国家工程院、国家科学院和硅谷工程名人堂。他领导了RISC I的设计与实现工作，并且是RAID项目的领导者。<br/>约翰·L. 亨尼斯（John L. Hennessy） <br/>Hennessy与Patterson共同荣获了2017年度“图灵奖”。Hennessy现为Google母公司Alphabet的董事长，之前曾任斯坦福大学第十任校长。他是IEEE和ACM会士，美国国家工程院、国家科学院、美国哲学院以及美国艺术与科学院院士。他于1981年开始研究MIPS项目，之后创办MIPS Computer Systems公司，开发了最早的商用RISC微处理器之一。他还领导了DASH项目，设计了第一个可扩展cache一致性多处理器原型。作者简介<br/>戴维·A. 帕特森（David A. Patterson） <br/>Patterson与Hennessy共同荣获了2017年度“图灵奖”，以表彰他们在计算机体系结构领域的开创性贡献。Patterson现为Google杰出工程师，之前为加州大学伯克利分校教授。他曾任ACM主席一职，目前是ACM和IEEE会士，美国艺术与科学院和计算机历史博物馆院士，并入选了美国国家工程院、国家科学院和硅谷工程名人堂。他领导了RISC I的设计与实现工作，并且是RAID项目的领导者。<br/>约翰·L. 亨尼斯（John L. Hennessy） <br/>Hennessy与Patterson共同荣获了2017年度“图灵奖”。Hennessy现为Google母公司Alphabet的董事长，之前曾任斯坦福大学第十任校长。他是IEEE和ACM会士，美国国家工程院、国家科学院、美国哲学院以及美国艺术与科学院院士。他于1981年开始研究MIPS项目，之后创办MIPS Computer Systems公司，开发了最早的商用RISC微处理器之一。他还领导了DASH项目，设计了第一个可扩展cache一致性多处理器原型。<br/><br/>译者简介<br/>易江芳<br/>北京大学信息科学技术学院计算机系副教授，长期从事微处理器体系结构设计和性能优化科研及教学工作，近年来主持和参加了国家科技重大专项、北京市科委等十余项科研项目，参与了北京大学“众志”系列自主CPU系统芯片的设计、验证和流片工作，发表论文10余篇。曾获北大方正奖教金，主持了北京大学计算机体系结构实习课程的教改项目。
刘先华<br/>北京大学信息科学技术学院计算机系副教授，长期从事计算机系统结构和编译优化科研及教学工作，近年来主持和参加了国家自然科学基金、国家科技重大专项等十余项科研项目，参与研发了北京大学“众志”系列自主CPU及配套软硬件系统并开展了相关产业化工作，发表论文20余篇。曾获首届“全国高校计算机专业优秀教师”奖励、宝钢奖教金、北京大学教学优秀奖等荣誉。</p>]<p><h2>目录</h2></p>
    出版者的话
赞誉
译者序
前言
作者简介
第1章　计算机抽象及相关技术  1
1.1　引言  1
1.1.1　传统的计算应用分类及其特点  2
1.1.2　欢迎来到后PC时代  3
1.1.3　你能从本书中学到什么  4
1.2　计算机体系结构中的8个伟大思想  6
1.2.1　面向摩尔定律的设计  6
1.2.2　使用抽象简化设计  7
1.2.3　加速经常性事件  7
1.2.4　通过并行提高性能  7
1.2.5　通过流水线提高性能  7
1.2.6　通过预测提高性能  7
1.2.7　存储层次  7
1.2.8　通过冗余提高可靠性  7
1.3　程序表象之下  8
1.4　箱盖后的硬件  10
1.4.1　显示器  11
1.4.2　触摸屏  12
1.4.3　打开机箱  13
1.4.4　数据安全  16
1.4.5　与其他计算机通信  16
1.5　处理器和存储制造技术  17
1.6　性能  20
1.6.1　性能的定义  21
1.6.2　性能的度量  23
1.6.3　CPU性能及其度量因素  24
1.6.4　指令性能  25
1.6.5　经典的CPU性能公式  26
1.7　功耗墙  28
1.8　沧海巨变：从单处理器向多处理器转变  30
1.9　实例：评测Intel Core i7  32
1.9.1　SPEC CPU基准评测程序  33
1.9.2　SPEC功耗基准评测程序  34
1.10　谬误与陷阱  35
1.11　本章小结  37
1.12　历史视角和拓展阅读  38
1.13　练习  38
第2章　指令：计算机的语言  43
2.1　引言  43
2.2　计算机硬件的操作  45
2.3　计算机硬件的操作数  47
2.3.1　存储器操作数  48
2.3.2　常数或立即数操作数  51
2.4　有符号数与无符号数  52
2.5　计算机中的指令表示  57
2.6　逻辑操作  62
2.7　用于决策的指令  65
2.7.1　循环  66
2.7.2　边界检查的简便方法  67
2.7.3　case/switch语句  68
2.8　计算机硬件对过程的支持  68
2.8.1　使用更多的寄存器  69
2.8.2　嵌套过程  71
2.8.3　在栈中为新数据分配空间  73
2.8.4　在堆中为新数据分配空间  74
2.9　人机交互  76
2.10　对大立即数的RISC-V编址和寻址  79
2.10.1　大立即数  79
2.10.2　分支中的寻址  80
2.10.3　RISC-V寻址模式总结  82
2.10.4　机器语言译码  83
2.11 　指令与并行性：同步  85
2.12　翻译并启动程序  87
2.12.1　编译器  87
2.12.2　汇编器  87
2.12.3　链接器  89
2.12.4　加载器  91
2.12.5　动态链接库  91
2.12.6　启动Java程序  93
2.13　以C排序程序为例的汇总整理  94
2.13.1　swap过程  94
2.13.2　sort过程  95
2.14　数组与指针  100
2.14.1　用数组实现clear  100
2.14.2　用指针实现clear  101
2.14.3　比较两个版本的clear  102
2.15　高级专题：编译C语言和解释Java语言  102
2.16　实例：MIPS指令  103
2.17　实例：x86指令  104
2.17.1　Intel x86的演变  104
2.17.2　x86寄存器和寻址模式  106
2.17.3　x86整数操作  107
2.17.4　x86指令编码  109
2.17.5　x86总结  110
2.18　实例：RISC-V指令系统的剩余部分  111
2.19　谬误与陷阱  112
2.20　本章小结  113
2.21　历史视角和扩展阅读  115
2.22　练习  115
第3章　计算机的算术运算  121
3.1　引言  121
3.2　加法和减法  121
3.3　乘法  124
3.3.1　串行版的乘法算法及其硬件实现  124
3.3.2　带符号乘法  127
3.3.3　快速乘法  127
3.3.4　RISC-V中的乘法  127
3.3.5　总结  128
3.4　除法  128
3.4.1　除法算法及其硬件实现  128
3.4.2　有符号除法  131
3.4.3　快速除法  131
3.4.4　RISC-V中的除法  132
3.4.5　总结  132
3.5　浮点运算  133
3.5.1　浮点表示  134
3.5.2　例外和中断  135
3.5.3　IEEE 754浮点数标准  135
3.5.4　浮点加法  138
3.5.5　浮点乘法  141
3.5.6　RISC-V中的浮点指令  144
3.5.7　精确算术  148
3.5.8　总结  150
3.6　并行性与计算机算术：子字并行  151
3.7　实例：x86中的SIMD扩展和高级向量扩展  151
3.8　加速：子字并行和矩阵乘法  153
3.9　谬误与陷阱  155
3.10　本章小结  158
3.11　历史视角和拓展阅读  159
3.12　练习  159
第4章　处理器  163
4.1　引言  163
4.1.1　一种基本的RISC-V实现  164
4.1.2　实现概述  164
4.2　逻辑设计的一般方法  166
4.3　建立数据通路  169
4.4　一个简单的实现方案  175
4.4.1　ALU控制  175
4.4.2　设计主控制单元  176
4.4.3　数据通路操作  180
4.4.4　控制的结束  182
4.4.5　为什么现在不使用单周期实现  182
4.5　流水线概述  183
4.5.1　面向流水线的指令系统设计  187
4.5.2　流水线冒险  187
4.5.3　总结  193
4.6　流水线数据通路和控制  194
4.6.1　流水线的图形化表示  203
4.6.2　流水线控制  205
4.7　数据冒险：前递与停顿  208
4.8　控制冒险  218
4.8.1　假设分支不发生  218
4.8.2　缩短分支延迟  219
4.8.3　动态分支预测  221
4.8.4　流水线总结  223
4.9　例外  223
4.9.1　RISC-V体系结构中如何处理例外  224
4.9.2　流水线实现中的例外  225
4.10　指令间的并行性  228
4.10.1　推测的概念  229
4.10.2　静态多发射  230
4.10.3　动态多发射处理器  234
4.10.4　高级流水线和能效  237
4.11　实例：ARM Cortex-A53和Intel Core i7流水线结构  238
4.11.1　ARM Cortex-A53  238
4.11.2　Intel Core i7 920  240
4.11.3　Intel Core i7处理器的性能  242
4.12　加速：指令级并行和矩阵乘法  243
4.13　高级专题：数字设计概述——使用硬件设计语言进行流水线建模以及更多流水线示例  246
4.14　谬误与陷阱  246
4.15　本章小结  247
4.16　历史视角和拓展阅读  247
4.17　练习  247
第5章　大而快：层次化存储  258
5.1　引言  258
5.2　存储技术  262
5.2.1　SRAM存储技术  262
5.2.2　DRAM存储技术  262
5.2.3　闪存  264
5.2.4　磁盘  264
5.3　cache基础  266
5.3.1　cache访问  268
5.3.2　处理cache失效  272
5.3.3　处理写操作  273
5.3.4　cache实例：Intrinsity FastMATH处理器  275
5.3.5　总结  276
5.4　cache的性能评估和改进  277
5.4.1　使用更为灵活的替换策略降低cache失效率  279
5.4.2　在cache中查找数据块  283
5.4.3　选择替换的数据块  284
5.4.4　使用多级cache减少失效代价  285
5.4.5　通过分块进行软件优化  287
5.4.6　总结  291
5.5　可靠的存储器层次  291
5.5.1　失效的定义  291
5.5.2　纠正1位错、检测2位错的汉明编码  293
5.6　虚拟机  296
5.6.1　虚拟机监视器的**条件  297
5.6.2　指令系统体系结构（缺乏）对虚拟机的支持  297
5.6.3　保护和指令系统体系结构  298
5.7　虚拟存储  298
5.7.1　页的存放和查找  301
5.7.2　缺页失效  303
5.7.3　支持大虚拟地址空间的虚拟存储  304
5.7.4　关于写  305
5.7.5　加快地址转换：TLB  306
5.7.6　Intrinsity FastMATH TLB  307
5.7.7　集成虚拟存储、TLB和cache  309
5.7.8　虚拟存储中的保护  311
5.7.9　处理TLB失效和缺页失效  312
5.7.10　总结  314
5.8　存储层次结构的一般框架  315
5.8.1　问题一：块可以被放在何处  315
5.8.2　问题二：如何找到块  316
5.8.3　问题三：当cache发生失效时替换哪一块  317
5.8.4　问题四：写操作如何处理  317
5.8.5　3C：一种理解存储层次结构的直观模型  318
5.9　使用有限状态自动机控制简单的cache  320
5.9.1　一个简单的cache  320
5.9.2　有限状态自动机  321
5.9.3　使用有限状态自动机作为简单的cache控制器  322
5.10　并行和存储层次结构：cache一致性  324
5.10.1　实现一致性的基本方案  325
5.10.2　监听协议  325
5.11　并行与存储层次结构：廉价磁盘冗余阵列  327
5.12　高级专题：实现缓存控制器  327
5.13　实例：ARM Cortex-A53和Intel Core i7的存储层次结构  327
5.14　实例：RISC-V系统的其他部分和特殊指令  331
5.15　加速：cache分块和矩阵乘法  331
5.16　谬误与陷阱  333
5.17　本章小结  336
5.18　历史视角和拓展阅读  337
5.19　练习  337
第6章　并行处理器：从客户端到云  348
6.1　引言  348
6.2　创建并行处理程序的难点  350
6.3　SISD、MIMD、SIMD、SPMD和向量机  354
6.3.1　x86中的SIMD：多媒体扩展  355
6.3.2　向量机  355
6.3.3　向量与标量  356
6.3.4　向量与多媒体扩展  357
6.4　硬件多线程  359
6.5　多核及其他共享内存多处理器  362
6.6　GPU简介  365
6.6.1　NVIDIA GPU体系结构简介  366
6.6.2　NVIDIA GPU存储结构  367
6.6.3　对GPU的展望  368
6.7　集群、仓储级计算机和其他消息传递多处理器  370
6.8　多处理器网络拓扑简介  374
6.9　与外界通信：集群网络  376
6.10　多处理器测试基准和性能模型  377
6.10.1　性能模型  379
6.10.2　Roofline模型  380
6.10.3　两代Opteron的比较  381
6.11　实例：评测Intel Core i7 960 和NVIDIA Tesla GPU的Roofline模型  384
6.12　加速：多处理器和矩阵乘法  388
6.13　谬误与陷阱  390
6.14　本章小结  391
6.15　历史视角和拓展阅读  393
6.16　练习  394
附录A　逻辑设计基础  402
术语表  460
网络内容
附录B　图形处理单元
附录C　将控制映射至硬件
附录D　精简指令系统体系结构计算机
扩展阅读
