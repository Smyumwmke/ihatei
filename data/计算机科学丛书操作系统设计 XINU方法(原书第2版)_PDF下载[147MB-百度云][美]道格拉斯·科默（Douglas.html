计算机科学丛书操作系统设计:XINU方法(原书第2版) PDF下载 [美]道格拉斯·科默（Douglas 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711162191
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711162191
<p>书名:计算机科学丛书操作系统设计:XINU方法(原书第2版)</p><p>作者:[美] 道格拉斯·科默（Douglas </p><p>页数:464</p><p>定价:¥99.0</p><p>出版社:机械工业出版社</p><p>出版日期:2019-04-01</p><p>ISBN:9787111621911</p><p><h2>本书特色</h2></p>[<p>
本书以Xinu（一个小型简洁的操作系统）为例，全面介绍操作系统设计方面的知识。本书着重讨论用于嵌入式设备的微内核操作系统，采用的方法是在现有的操作系统课程中纳入更多的嵌入式处理内容，而非引入一门教读者如何在嵌入式系统上编程的新课程。<br/>本书从底层机器开始，一步步地设计和实现一个小型但优雅的操作系统Xinu，指导读者通过实用、简单的原语来构造传统的基于进程的操作系统。本书回顾了主要的系统组件，并利用分层设计范式，以一种有序、易于理解的方式组织内容。<br/>作者的网站www.xinu.cs.purdue.edu提供了便于学生搭建实验环境的软件和资料。<br/>
</p>]<p><h2>内容简介</h2></p>[<p>本书以Xinu（一个小型简洁的操作系统）为例，全面介绍操作系统设计方面的知识。本书着重讨论用于嵌入式设备的微内核操作系统，采用的方法是在现有的操作系统课程中纳入更多的嵌入式处理内容，而非引入一门教读者如何在嵌入式系统上编程的新课程。本书从底层机器开始，一步步地设计和实现一个小型但优雅的操作系统Xinu，指导读者通过实用、简单的原语来构造传统的基于进程的操作系统。本书回顾了主要的系统组件，并利用分层设计范式，以一种有序、易于理解的方式组织内容。作者的网站www.xinu.cs.purdue.edu提供了便于学生搭建实验环境的软件和资料。</p>]<p><h2>目录</h2></p>
    出版者的话译者序前言关于作者第1章　引言和概述11.1　操作系统11.2　本书的研究方法21.3　分层设计21.4　Xinu操作系统41.5　操作系统的界定41.6　从外部看操作系统51.7　其他章节概要61.8　观点61.9　总结7练习7第2章　并发执行与操作系统服务82.1　引言82.2　多活动的编程模型82.3　操作系统服务92.4　并发处理的概念和术语92.5　串行程序和并发程序的区别112.6　多个进程共享同一段代码122.7　进程退出与进程终止142.8　共享内存、竞争条件和同步142.9　信号量与互斥182.10　Xinu中的类型命名方法192.11　使用kputc和kprintf进行操作系统的调试202.12　观点202.13　总结21练习21第3章　硬件与运行时环境概述223.1　引言223.2　开发平台的物理和逻辑架构223.3　指令集233.4　通用寄存器233.5　I/O总线和存-取范例243.6　DMA机制253.7　总线地址空间253.8　总线启动和配置263.9　函数调用约定和运行时栈263.10　中断和中断处理283.11　中断向量293.12　异常向量和异常处理293.13　时钟硬件293.14　串行通信303.15　轮询与中断驱动I/O303.16　存储布局303.17　内存保护313.18　硬件细节和片上系统体系结构313.19　观点313.20　硬件参考资料32练习32第4章　链表与队列操作334.1　引言334.2　进程链表的统一数据结构334.3　简洁的链表数据结构344.4　队列数据结构的实现354.5　内联队列操作函数364.6　获取链表中进程的基础函数374.7　FIFO队列操作384.8　优先级队列的操作404.9　链表初始化424.10　观点434.11　总结43练习43第5章　调度和上下文切换455.1　引言455.2　进程表455.3　进程状态475.4　就绪和当前状态485.5　调度策略485.6　调度的实现495.7　推迟重新调度525.8　上下文切换的实现525.9　内存中保存的状态525.10　上下文切换操作535.11　重新启动进程执行的地址565.12　并发执行和空进程575.13　使进程就绪和调度常量575.14　其他进程调度算法585.15　观点585.16　总结59练习59第6章　更多进程管理606.1　引言606.2　进程挂起和恢复606.3　自我挂起和信息隐藏606.4　系统调用616.5　禁止和恢复中断626.6　系统调用模板636.7　系统调用返回值SYSERR和OK636.8　挂起的实现646.9　挂起当前进程656.10　suspend函数的返回值656.11　进程终止和进程退出666.12　进程创建686.13　其他进程管理函数726.14　总结74练习74第7章　协调并发进程767.1　引言767.2　进程同步的必要性767.3　计数信号量的概念777.4　避免忙等待777.5　信号量策略和进程选择777.6　等待状态787.7　信号量数据结构797.8　系统调用wait797.9　系统调用signal807.10　静态和动态信号量分配817.11　动态信号量的实现示例827.12　信号量删除837.13　信号量重置847.14　并行处理器（多核）之间的协调857.15　观点867.16　总结86练习87第8章　消息传递888.1　引言888.2　两种类型的消息传递服务888.3　消息使用资源的限制898.4　消息传递函数和状态转换898.5　send的实现908.6　receive的实现918.7　非阻塞消息接收的实现928.8　观点928.9　总结92练习93第9章　基本内存管理949.1　引言949.2　内存的类型949.3　重量级进程的定义959.4　示例系统的内存管理959.5　程序段和内存区域959.6　动态内存分配969.7　底层内存管理器的设计979.8　分配策略和内存持久性979.9　追踪空闲内存989.10　底层内存管理的实现989.11　使用空闲内存的数据结构定义999.12　分配堆存储1009.13　分配栈存储1029.14　堆和栈存储的释放1039.15　观点1059.16　总结106练习106第10章　高级内存管理和虚拟内存10710.1　引言10710.2　分区空间分配10710.3　缓冲池10810.4　分配缓冲区10810.5　将缓冲区返还给缓冲池11010.6　创建缓冲池11110.7　初始化缓冲池表11210.8　虚拟内存和内存复用11310.9　实地址空间和虚地址空间11310.10　支持按需分页的硬件11410.11　使用页表的地址转换11410.12　页表项中的元数据11510.13　按需分页以及设计上的问题11610.14　页面替换和全局时钟算法11610.15　观点11710.16　总结117练习118第11章　高层消息传递11911.1　引言11911.2　进程间通信端口11911.3　端口实现11911.4　端口表初始化12011.5　端口创建12111.6　向端口发送消息12211.7　从端口接收消息12411.8　端口的删除和重置12511.9　观点12811.10　总结128练习128第12章　中断处理13012.1　引言13012.2　中断的优点13012.3　中断处理13012.4　中断向量13112.5　中断和异常集成13112.6　使用代码的ARM异常向量13212.7　设备中断向量号的分配13512.8　中断分派13612.9　中断的软件结构13712.10　禁止中断13912.11　中断代码调用函数的限制14012.12　中断过程中重新调度的必要性14012.13　中断过程中的重新调度14012.14　观点14112.15　总结142练习142第13章　实时时钟管理14313.1　引言14313.2　定时事件14313.3　实时时钟和计时器硬件14313.4　实时时钟中断处理14413.5　延时与抢占14513.6　抢占的实现14513.7　使用增量链表对延迟进行有效管理14613.8　增量链表的实现14713.9　将进程转入睡眠14813.10　定时消息接收15013.11　唤醒睡眠进程15413.12　时钟中断处理15413.13　时钟初始化15613.14　观点15913.15　总结159练习159第14章　设备无关的I/O16114.1　引言16114.2　I/O和设备驱动的概念结构16114.3　接口抽象和驱动抽象16214.4　I/O接口示例16314.5　打开-读-写-关闭范例16314.6　绑定I/O操作和设备名16414.7　Xinu中的设备名16414.8　设备转换表概念16514.9　设备的多个副本和共享驱动16614.10　高层I/O操作的实现16814.11　其他高层I/O函数16914.12　打开、关闭和引用计数17214.13　devtab中的空条目和错误条目17414.14　I/O系统的初始化17414.15　观点17814.16　总结179练习179第15章　设备驱动示例18015.1　引言18015.2　使用UART硬件进行串行通信18015.3　tty抽象18015.4　tty设备驱动的组织结构18115.5　请求队列和缓冲区18215.6　上半部和下半部的同步18315.7　UART硬件FIFO与驱动设计18415.8　控制块的概念18415.9　tty控制块和数据声明18415.10　次设备号18615.11　上半部tty字符输入（ttygetc）18715.12　上半部tty读取函数（ttyread）18815.13　上半部tty字符输出（ttyputc）18915.14　开始输出（ttykickout）19015.15　上半部tty多字符输出（ttywrite）19115.16　下半部tty驱动函数（ttyhandler）19215.17　输出中断处理（ttyhandle_out）19415.18　tty输入处理（ttyhandle_in）19615.19　tty控制块初始化（ttyinit）20215.20　设备驱动控制（ttycontrol）20415.21　观点20515.22　总结205练习206第16章　DMA设备和驱动（以太网）20716.1　引言20716.2　直接内存访问和缓冲区20716.3　多个缓冲区和缓冲区环20716.4　使用DMA的以太网驱动示例20816.5　设备的硬件定义和常量20916.6　环和内存缓冲区21116.7　以太网控制块的定义21316.8　设备和驱动初始化21516.9　从以太网设备读取数据包22116.10　向以太网设备写入数据包22316.11　以太网设备的中断处理22516.12　以太网控制函数22816.13　观点22916.14　总结229练习229第17章　*小互联网协议栈23017.1　引言23017.2　所需的功能23017.3　同步会话、超时和网络处理进程23117.4　设计的影响23217.5　ARP函数23217.6　网络数据包的定义24117.7　网络输入进程24217.8　IP的相关定义24517.9　IP函数24617.10　UDP表的定义25517.11　UDP函数25617.12　互联网控制报文协议26717.13　动态主机配置协议26817.14　观点27517.15　总结275练习275第18章　远程磁盘驱动27718.1　引言27718.2　磁盘抽象27718.3　磁盘驱动支持的操作27718.4　块传输和高层I/O函数27718.5　远程磁盘范例27818.6　高速缓存的重要概念27818.7　磁盘操作的语义27918.8　驱动数据结构的定义28018.9　驱动初始化（rdsinit）28418.10　上半部打开函数（rdsopen）28718.11　远程通信函数（rdscomm）28918.12　上半部写函数（rdswrite）29118.13　上半部读函数（rdsread）29318.14　刷新挂起的请求29618.15　上半部控制函数（rdscontrol）29718.16　分配磁盘缓冲区（rdsbufalloc）29918.17　上半部关闭函数（rdsclose）30018.18　下半部通信进程（rdsprocess）30218.19　观点30618.20　总结306练习306第19章　文件系统30819.1　什么是文件系统30819.2　文件操作的示例集30819.3　本地文件系统的设计30919.4　Xinu文件系统的数据结构30919.5　索引管理器的实现31019.6　清空索引块（lfibclear）31419.7　获取索引块（lfibget）31519.8　存储索引块（lfibput）31519.9　从空闲链表中分配索引块（lfiballoc）31619.10　从空闲链表中分配数据块（lfdballoc）31719.11　使用设备无关的I/O函数进行文件操作31919.12　文件系统的设备配置和函数名称32019.13　本地文件系统打开函数（lfsopen）32019.14　关闭文件伪设备（lflclose）32619.15　刷新磁盘中的数据（lfflush）32819.16　文件的批量传输函数（lflwrite、lflread）32819.17　在文件中查找新位置（lflseek）33019.18　从文件中提取一字节（lflgetc）33119.19　改变文件中的一字节（lflputc）33219.20　载入索引块和数据块（lfsetup）33419.21　主文件系统设备的初始化（lfsinit）33719.22　伪设备的初始化（lflinit）33819.23　文件截断（lftruncate）33919.24　初始文件系统的创建（lfscreate）34119.25　观点34319.26　总结343练习343第20章　远程文件机制34520.1　引言34520.2　远程文件访问34520.3　远程文件语义34520.4　远程文件设计和消息34620.5　远程文件服务器通信（rfscomm）35220.6　发送基本消息（rfsndmsg）35420.7　网络字节序35520.8　使用设备范例的远程文件系统35520.9　打开远程文件（rfsopen）35620.10　检查文件模式（rfsgetmode）35920.11　关闭远程文件（rflclose）36020.12　读远程文件（rflread）36120.13　写远程文件（rflwrite）36320.14　远程文件的定位（rflseek）36520.15　远程文件单字符I/O（rflgetc、rflputc）36620.16　远程文件系统控制函数（rfscontrol）36720.17　初始化远程文件系统（rfsinit、rflinit）37020.18　观点37220.19　总结372练习372第21章　句法名字空间37421.1　引言37421.2　透明与名字空间抽象37421.3　多种命名方案37521.4　命名系统设计的其他方案37621.5　基于句法的名字空间37621.6　模式和替换37621.7　前缀模式37721.8　名字空间的实现37721.9　名字空间的数据结构和常量37721.10　增加名字空间前缀表的映射37821.11　使用前缀表进行名字映射37921.12　打开命名文件38321.13　名字空间初始化38321.14　对前缀表中的项进行排序38621.15　选择逻辑名字空间38621.16　默认层次和空前缀38721.17　额外的对象操作函数38721.18　名字空间方法的优点和限制38821.19　广义模式38821.20　观点38921.21　总结389练习390第22章　系统初始化39122.1　引言39122.2　引导程序：从零开始39122.3　一个通过网络启动的例子39222.4　操作系统初始化39222.5　Xinu初始化39322.6　Xinu系统启动39522.7　从程序转化为进程39922.8　观点39922.9　总结399练习400第23章　子系统初始化和内存标记40123.1　引言40123.2　自初始化模块40123.3　并发系统中的自初始化模块40223.4　重新启动后的自初始化40323.5　使用登录号初始化40423.6　广义内存标记方案40523.7　内存标记系统的数据声明40623.8　标记的实现40723.9　观点40823.10　总结408练习408第24章　异常处理40924.1　引言40924.2　术语：故障、检测、陷阱和异常40924.3　向量异常和可屏蔽中断 40924.4　异常的类型41024.5　处理异常41024.6　异常向量初始化41124.7　面对灾难时的panic41124.8　panic函数的实现41124.9　观点41224.10　总结412练习412第25章　系统配置41325.1　引言41325.2　多重配置的需求41325.3　Xinu系统配置41425.4　Xinu配置文件的内容41425.5　计算次设备号41625.6　配置Xinu系统的步骤41725.7　观点41725.8　总结417练习417第26章　一个用户接口例子：Xinu shell41926.1　引言41926.2　什么是用户接口41926.3　命令和设计原则41926.4　一个简化shell的设计决策42026.5　shell的组织和操作42026.6　词法符号的定义42126.7　命令行语法的定义42126.8　Xinu shell的实现42226.9　符号的存储42426.10　词法分析器代码42426.11　命令解释器的核心42826.12　命令名查询和内部处理43426.13　传递给命令的参数43526.14　向外部命令传递参数43526.15　I/O重定向43826.16　命令函数（sleep）的例子43926.17　观点44026.18　总结441练习441附录1　操作系统移植443附录2　Xinu设计注解450索引454
