软件测试实用教程 PDF下载 刘震 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711544418
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711544418
<p>书名:软件测试实用教程</p><p>作者:刘震</p><p>页数:245</p><p>定价:¥45.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-03-01</p><p>ISBN:9787115444189</p><p><h2>本书特色</h2></p>[<p>
软件测试是一门涉及广泛知识的学科，软件测试行业在国内方兴未艾，测试工程师们亟须掌握各种测试技术和工具，测试团队的管理也亟须完善和提高。
本书在编写过程中考虑到测试人员的需求，尤其是测试新手对各种知识的需求，提供了丰富的测试知识：首先介绍了国内外先进的测试技术和测试理念，如微软的测试方法、RUP中的测试过程、敏捷测试的理念等；其次详细讲述了几个主要测试工具的使用，如LoadRunner、AppScan等；然后介绍了各种常用的开源测试工具，为期待引入开源测试工具的团队提供参考；*后，结合项目实践，介绍了自动化测试框架的开发。本书在每章的*后，针对本章重要内容给出习题，方便大家进行自测。
本书适合作为高校软件测试相关课程教学用书，也适合从事测试工作的人员参考使用。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书在介绍各种测试方法和技术时，采用了浅显易懂的例子，在介绍测试工具时也使用了大量的例子和代码，方便读者自己进行实践和演练，在介绍测试工具的开发时更是提供了丰富完整的开发示例代码，读者可直接使用，或者根据自己的实际情况进行调整。 </p>]<p><h2>作者简介</h2></p>[<p>作者为编写经验丰富的工作室和教学经验丰富的高校老师相结合，密切紧跟行业需求，内容详细实用。曾经出版过一系列畅销书籍。</p>]<p><h2>目录</h2></p>


第1篇　软件测试的理论基础

第1章　了解软件测试行业　2
1.1　软件测试的发展历程　2
1.2　软件测试的组织形式　4
1.2.1　软件鼻祖微软的经验教训　4
1.2.2　软件测试组织的雏形　4
1.2.3　组织形式的分类　5
1.2.4　综合型的测试组织　6
1.3　软件开发模式的分类　7
1.3.1　软件开发模式的发展　7
1.3.2　线性模型　8
1.3.3　渐进式模型　8
1.3.4　变换模型　9
1.3.5　RUP过程模型　9
1.3.6　敏捷运动　11
1.3.7　极限编程（XP）　12
1.4　不同软件开发模式下的软件测试　13
1.4.1　CMMI和ISO中的软件测试　13
1.4.2　CMMI与软件测试　13
1.4.3　ISO与软件测试　14
1.4.4　敏捷开发中的软件测试　15
1.5　小结　16
1.6　习题　16
第2章　软件质量与软件测试　18
2.1　软件质量属性　18
2.1.1　质量的3个层次　18
2.1.2　软件质量模型　19
2.1.3　ISO 9000质量管理体系与八项质量管理原则　20
2.1.4　ISO 9000质量管理体系的建立过程　20
2.1.5　CMMI质量管理体系与过程改进　21
2.1.6　结合PSP、TSP建立CMMI过程
改进体系　21
2.1.7　应用PDCA质量控制法持续改进软件质量　21
2.2　软件质量保证与软件测试　22
2.2.1　SQA与软件测试　22
2.2.2　SQA的工作内容　22
2.2.3　QA与QC的区别　23
2.3　小结　23
2.4　习题　24
第3章　软件测试的目的与原则　25
3.1　软件测试的目的　25
3.1.1　测试是为了建立软件的信心　25
3.1.2　软件测试与软件信心的关系　25
3.1.3　软件测试的两面性　26
3.1.4　软件测试的验证与确认　26
3.1.5　测试是一种服务　27
3.2　软件测试应该遵循的原则　27
3.2.1　Good enough原则　27
3.2.2　Pareto原则　28
3.2.3　尽可能早开展测试　28
3.2.4　在发现比较多错误的地方需要投入更多的测试　29
3.2.5　同化效应　29
3.3　小结　29
3.4　习题　30
第4章　软件测试的方法论　31
4.1　软件测试的5大流派　31
4.1.1　分析学派　31
4.1.2　标准学派　32
4.1.3　质量学派　32
4.1.4　上下文驱动学派　32
4.1.5　敏捷学派　33
4.1.6　不同流派的测试定义　33
4.2　软件测试的方法应用　34
4.2.1　微软公司的**类测试　34
4.2.2　微软公司的第二类测试　35
4.2.3　微软的缺陷管理　35
4.3　IBM公司的软件测试方法　35
4.3.1　回归测试　35
4.3.2　测试的度量　36
4.3.3　用例驱动　36
4.3.4　RUP对软件测试的分类　36
4.3.5　RUP对测试阶段的划分　38
4.4　自动错误预防（AEP）方法　38
4.4.1　AEP的基本概念　38
4.4.2　实现软件自动错误预防的5大法则　39
4.5　小结　41
4.6　习题　42
第5章　软件测试的过程管理　44
5.1　软件测试的各个阶段　44
5.2　测试需求　45
5.2.1　需求规格说明书的检查要点　45
5.2.2　需求文档的检查步骤　45
5.2.3　通过编写测试用例来检查需求　48
5.3　测试的计划　49
5.3.1　为什么要制定测试计划　49
5.3.2　测试计划是对测试过程的整体设计　49
5.3.3　确定测试范围　50
5.3.4　制定测试策略　50
5.3.5　安排好测试资源　51
5.3.6　安排好进度　51
5.3.7　计划风险　52
5.4　测试的设计及测试用例　52
5.4.1　基于需求的测试用例设计　52
5.4.2　等价类划分法　53
5.4.3　边界值分析法　54
5.4.4　等价类 边界值　56
5.4.5　基本路径分析法　56
5.4.6　因果图法　57
5.4.7　场景设计法　58
5.4.8　错误猜测法　59
5.4.9　正交表与TCG的使用　59
5.4.10　利用均匀试验法设计测试用例　61
5.4.11　组合覆盖与PICT的使用　62
5.4.12　分类树与TESTONA的使用　64
5.4.13　测试用例设计的自动化　66
5.4.14　敏捷测试用例设计　67
5.4.15　测试用例的粒度　67
5.4.16　基于需求的测试用例设计　67
5.4.17　测试用例数据生成的自动化　68
5.5　测试的执行　68
5.5.1　测试用例的合理选择　68
5.5.2　测试的分工与资源利用　69
5.5.3　测试环境的搭建　69
5.5.4　BVT测试与冒烟测试　70
5.5.5　每日构建的基本流程　70
5.5.6　通过每日构建来规范源代码管理　71
5.5.7　通过每日构建来控制版本风险　71
5.6　测试的记录和跟踪　72
5.6.1　Bug的质量衡量　72
5.6.2　如何录入一个合格的Bug　72
5.6.3　Bug报告应该注意的几个问题　72
5.6.4　基于QC的缺陷管理　73
5.7　回归测试　73
5.7.1　为什么会回归　73
5.7.2　回归测试的难度　74
5.7.3　基于风险的回归测试　74
5.8　测试总结和报告　75
5.8.1　缺陷分类报告　76
5.8.2　缺陷趋势报告　76
5.8.3　典型缺陷与Bug模式　77
5.8.4　测试中的PDCA循环　78
5.8.5　客观全面的测试报告　79
5.8.6　实用测试经验的总结　79
5.9　小结　80
5.10　习题　80


第2篇　软件测试的技术与工具
第6章　软件测试技术　82
6.1　常见的软件测试技术　82
6.1.1　黑盒测试　82
6.1.2　白盒测试　83
6.1.3　自动化测试　84
6.1.4　手工测试　84
6.1.5　单元测试　84
6.1.6　性能测试　86
6.1.7　压力测试　89
6.1.8　安全测试　89
6.1.9　安装测试　91
6.1.10　环境测试　93
6.2　巧用Windows自带的小工具　95
6.2.1　找到Windows的任务管理器　95
6.2.2　检查进程驻留　95
6.2.3　检查内存问题　95
6.2.4　检查网络使用情况　95
6.2.5　检查CPU使用情况　96
6.2.6　Perfmon的性能监控　97
6.2.7　NetStat的网络监视　100
6.3　小结　101
6.4　习题　101
第7章　测试管理工具QC的应用　103
7.1　测试管理平台　103
7.1.1　测试过程管理规范化　103
7.1.2　测试管理平台—QC简介　104
7.1.3　QC安装　105
7.2　测试需求管理　110
7.2.1　定义测试需求　110
7.2.2　把需求项转换成测试计划　111
7.3　测试计划管理　112
7.3.1　测试用例的管理　112
7.3.2　设计测试步骤　112
7.3.3　测试用例的重用　113
7.3.4　测试用例对需求项的覆盖　114
7.4　测试执行　115
7.4.1　定义测试集　115
7.4.2　为测试集添加测试用例　115
7.4.3　执行测试　116
7.5　缺陷登记与跟踪　117
7.5.1　添加新缺陷　117
7.5.2　如何避免录入冗余的缺陷　117
7.5.3　BUG的生命周期　118
7.5.4　把缺陷链接到测试　119
7.6　在QC中生成测试报告的图表　120
7.7　基于QC的测试项目管理　121
7.7.1　QC的库结构　121
7.7.2　创建QC项目库　121
7.7.3　定制项目　121
7.7.4　添加项目组成员　122
7.7.5　自定义QC的数据字段　123
7.7.6　配置跟踪提醒规则　126
7.7.7　设置警报规则　128
7.7.8　设置工作流　129
7.7.9　“缺陷模块”列表自定义　129
7.7.10　脚本编辑器　130
7.7.11　QC项目的导入/导出　131
7.8　小结　133
7.9　习题　133
第8章　功能自动化测试工具UFT的
应用　135
8.1　如何开展功能自动化测试　135
8.1.1　选取合适的测试项目来开展自动化测试　135
8.1.2　自动化测试工程师的知识体系　135
8.1.3　自动化测试工具选型　136
8.1.4　自动化测试项目计划　137
8.2　使用UFT开展功能自动化测试　139
8.2.1　UFT的安装　139
8.2.2　使用UFT录制脚本　139
8.2.3　使用关键字视图和专家视图编辑脚本　142
8.2.4　回放脚本　143
8.2.5　插入检查点　144
8.3　构建功能自动化测试框架　147
8.3.1　模块化框架　147
8.3.2　函数库结构框架　149
8.3.3　数据驱动框架　150
8.4　小结　152
8.5　习题　153
第9章　性能测试工具LoadRunner的应用　154
9.1　如何开展性能测试　154
9.1.1　性能测试工程师的素质要求　154
9.1.2　认识性能测试　155
9.1.3　性能测试的类型　156
9.1.4　性能测试成熟度模型　157
9.1.5　分析和定义性能需求　158
9.1.6　“不成文的”性能需求定义　159
9.1.7　计划性能测试　160
9.2　使用LoadRunner开展性能测试　160
9.2.1　LoadRunner简介　160
9.2.2　LoadRunner基本使用方法和步骤　162
9.2.3　选择协议　164
9.2.4　录制脚本　165
9.2.5　常见脚本回放问题解决　167
9.2.6　修改和完善脚本　168
9.2.7　脚本参数化　169
9.2.8　添加事务　170
9.2.9　添加内容检查点　171
9.2.10　性能参数的选择和监视　172
9.2.11　运行场景　173
9.2.12　选择需要监控的性能参数　173
9.2.13　性能测试报告与性能瓶颈分析　173
9.3　小结　175
9.4　习题　175
第10章　安全漏洞的分析与测试　176
10.1　常见安全漏洞分析　176
10.1.1　缓冲区溢出　176
10.1.2　整数溢出　178
10.1.3　命令注入　179
10.1.4　SQL注入　179
10.1.5　XSS ?C 跨站脚本攻击　181
10.2　使用AppScan进行安全测试　183
10.2.1　AppScan简介　183
10.2.2　利用AppScan进行Web安全测试　183
10.2.3　使用AppScan测试AltoroJ项目　184
10.3　小结　187
10.4　习题　188
第11章　单元测试工具MSTest的应用　189
11.1　单元测试范围管理　189
11.1.1　单元测试的分类　189
11.1.2　静态单元测试　190
11.1.3　动态单元测试　191
11.1.4　单元测试的要求　191
11.1.5　单元测试的效果　191
11.1.6　单元测试的范围　191
11.2　单元测试的过程管理　192
11.2.1　单元测试的过程策划　192
11.2.2　单元测试的组织　192
11.2.3　单元测试模式的选择　192
11.2.4　单元测试的策略　192
11.2.5　单元测试用例的设计　193
11.2.6　代码标准和规范　193
11.2.7　代码审查制度　193
11.2.8　单元测试的流程　194
11.2.9　单元测试与每日构建的结合　194
11.2.10　单元测试的自动化方面　195
11.3　单元测试的质量度量　196
11.3.1　单元测试覆盖率　196
11.3.2　单元测试评审　197
11.4　单元测试工具MSTest的应用　197
11.4.1　建立单元测试项目　198
11.4.2　巧用NMock对象　199
11.4.3　对缺乏接口实现的类的方法进行测试　199
11.4.4　使用NMock对象　200
11.4.5　使用NMock的场合　201
11.4.6　单元测试的执行　201
11.4.7　测试管理　201
11.4.8　运行测试代码　201
11.4.9　查看测试结果　201
11.5　数据驱动的单元测试　202
11.5.1　为什么要使用数据驱动的方式　202
11.5.2　创建数据驱动单元测试　202
11.5.3　使用数据源　204
11.5.4　使用配置文件定义数据源　204
11.5.5　编写单元测试代码使用配置文件定义的数据源　205
11.6　小结　206
11.7　习题　206
第12章　开源测试工具　207
12.1　开源测试工具简介　207
12.1.1　开源的背景　207
12.1.2　开源测试工具的发展现状　207
12.1.3　开源测试工具的分布　207
12.1.4　开源测试工具的来源　208
12.1.5　开源测试工具的优势　208
12.1.6　开源测试工具的不足　208
12.2　常用开源测试工具介绍—测试管理类　209
12.2.1　Bugzilla　209
12.2.2　Mantis　210
12.2.3　BugFree　211
12.2.4　综合比较　211
12.3　常用开源测试工具介绍—单元测试类　212
12.3.1　NUnit　212
12.3.2　NMock　213
12.3.3　NUnitForms　214
12.4　常用开源测试工具介绍—性能测试类　215
12.4.1　JMeter　215
12.4.2　TestMaker　217
12.4.3　DBMonster　217
12.5　常用开源测试工具介绍—自动化功能测试类　219
12.5.1　Abbot Java GUI Test Framework　220
12.5.2　White　221
12.5.3　Watir　222
12.6　如何在测试组中引入开源测试工具　224
12.6.1　开源测试工具的成本考虑　224
12.6.2　引入开源测试工具的步骤　224
12.6.3　引入开源测试工具可能碰到的问题　225
12.7　小结　226
12.8　习题　226
第13章　用户界面测试管理　227
13.1　用户界面测试的必要性　227
13.2　如何进行用户界面测试　228
13.2.1　用户界面测试的时机　228
13.2.2　后期修改界面的风险　228
13.2.3　界面测试遗漏　228
13.2.4　用户界面测试的要点　228
13.2.5　减少用户的工作量　229
13.2.6　“少就是多”　229
13.3　用户界面测试原则　229
13.3.1　亲和力　230
13.3.2　协助　231
13.3.3　有效　232
13.3.4　鼓励　232
13.3.5　熟悉　233
13.3.6　明显　233
13.3.7　个性化　234
13.3.8　安全　234
13.3.9　满意　235
13.3.10　简单　235
13.3.11　支持　235
13.3.12　多样性　236
13.4　小结　236
13.5　习题　237
第14章　自动化测试项目实战　238
14.1　自动化测试用例设计　238
14.1.1　手工测试用例与自动化测试用例　238
14.1.2　测试类型　239
14.1.3　自动化测试用例编写原则　239
14.2　BBS社区项目实战　240
14.2.1　准备工作　240
14.2.2　项目结构介绍　241
14.2.3　配置文件　241
14.2.4　样本与执行结果　242
14.2.5　编写测试用例　242
14.2.6　执行测试用例　245
14.3　小结　245
14.4　习题　245

