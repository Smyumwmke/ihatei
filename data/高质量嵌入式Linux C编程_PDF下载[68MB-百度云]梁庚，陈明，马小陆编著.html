高质量嵌入式Linux C编程 PDF下载 梁庚，陈明，马小陆编著 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712125383
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712125383
<p>书名:高质量嵌入式Linux C编程</p><p>作者:梁庚，陈明，马小陆编著</p><p>页数:14</p><p>定价:¥68.0</p><p>出版社:电子工业出版社</p><p>出版日期:2015-01-01</p><p>ISBN:9787121253836</p><p><h2>本书特色</h2></p>[<p>
本书从嵌入式开发角度出发，以linux操作系统为开发平台，将隐藏在系统开发背后的关于c语言、计算机组成原理、计算机操作系统等方面的机制和知识娓娓道来，不仅能让读者知其然，更要让读者知其所以然，揭开嵌入式linux c系统开发背后鲜为人知的秘密，并让这些知识再反作用于编程实践，从而帮助读者写出高质量的嵌入式linux c代码。具体说来，本书主要讨论了包括嵌入式c语言高级编程、嵌入式linux系统编程、多任务解决机制、网络编程等多个方面的话内容。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书从嵌入式开发角度出发, 以Linux操作系统为开发平台, 将隐藏在系统开发背后的关于C语言、计算机组成原理、计算机操作系统等方面的机制和知识娓娓道来, 不仅能让读者知其然, 更要让读者知其所以然, 揭开嵌入式Linux C系统开发背后鲜为人知的秘密, 并让这些知识再反作用于</p>]<p><h2>目录</h2></p>
    第1章 嵌入式linux c语言开发工具1.1 嵌入式linux c语言开发概述1.2 嵌入式linux c开发环境1.3 嵌入式文本编辑器1.3.1 基本模式1.3.2 基本操作1.3.3 实训操作1.4 嵌入式编译器1.4.1 初识gcc编译器1.4.2 gcc命令常用选项及工作流程1.4.3 库的使用1.5 嵌入式调试器1.6 工程管理器1.6.1 makefile1.6.2 makefile特性介绍1.7 eclipse程序开发1.7.1 eclipse环境安装1.7.2 eclipse c程序开发第2章 数据类型2.1 变量与常量2.2 变量2.2.1 什么是变量2.2.2 变量名和变量值2.2.3 局部变量和全局变量2.3 常量2.4 基本内置类型2.4.1 数据类型大小2.4.2 陷阱之有符号与无符号2.5 声明与定义2.5.1 定义2.5.2 声明2.6 乱世枭雄：static与extern2.6.1 政权旗帜static2.6.2 外来的和尚会念经extern2.7 铁布衫：const2.8 隐形刺客：auto2.9 闪电飞刀：register2.10 专一王子：volatile2.11 typedef详解2.11.1 typedef与结构的问题2.11.2 typedef与#define的问题2.11.3 typedef与#define的另一例2.11.4 typedef与复杂的变量声明2.12 枚举2.12.1 枚举类型的使用方法2.12.2 枚举与#define 宏的区别2.13 联合体2.13.1 联合体的定义2.13.2 从两道经典试题谈联合体（union）的使用第3章 运算符、表达式3.1 运算符简介3.1.1 运算符优先级3.1.2 一些容易出错的优先级问题3.1.3 逻辑运算符3.2 条件运算符和条件表达式3.3 ++、操作符3.4 位运算3.4.1 按位与运算及应用3.4.2 按位或运算及应用3.4.3 按位异或运算及应用3.4.4 左移和右移3.5 c语言性能优化：使用位操作第4章 语句4.1 空语句4.2 基础语句4.2.1 表达式语句4.2.2 函数调用语句4.3 语句if4.3.1 布尔变量与零值比较4.3.2 整型变量与零值比较4.3.3 浮点变量与零值比较4.3.4 指针变量与零值比较4.3.5 对if语句的补充说明4.4 跳转语句：goto4.5 循环语句4.5.1 do—while语句4.5.2 for语句4.5.3 循环语句的效率4.6 break和continue4.6.1 break语句4.6.2 continue语句4.7 switch语句第5章 数组与指针5.1 数组认知5.2 使用数组之常见问题5.2.1 数组的下标总是从0开始吗5.2.2 可以使用数组后面**个元素的地址吗5.2.3 为什么要小心对待位于数组后面的那些元素的地址呢5.2.4 数组作为参数传递给函数时，可以通过sizeof得到数组的大小吗5.2.5 指针或带下标的数组名都可以访问元素，哪一种更好呢5.2.6 可以把另外一个地址赋给一个数组名吗5.2.7 array_name和＆array_name有什么不同5.2.8 为什么用const说明的常量不能用来定义一个数组的初始大小5.2.9 字符串和数组有什么不同5.3 指针5.3.1 指针是变量5.3.2 指针的类型和指针所指向的类型5.3.3 指针的值5.3.4 指针本身所占据的内存区5.4 指针的运算5.4.1 指针的算术运算5.4.2 指针的关系运算5.4.3 间接引用5.4.4 *多可以使用几层指针5.5 常量指针和指针常量5.5.1 常量指针与指针常量的实例5.5.2 常量指针的应用5.6 空指针及其使用5.6.1 null总是被定义为0吗5.6.2 null总是等于0吗5.6.3 空指针的使用5.7 指针void：万能指针5.8 指针数组与数组指针5.9 字符串函数详解5.10 函数指针与指针函数5.11 复杂指针声明：“int * （* （*fp1） （int） ）（10）；”5.11.1 基础5.11.2 const修饰符5.11.3 typedef的妙用5.11.4 函数指针5.11.5 右左法则第6章 内存管理6.1 你的数据放在哪里6.1.1 未初始化的全局变量（.bss段）6.1.2 初始化过的全局变量（.data段）6.1.3 常量数据（.rodata段）6.1.4 代码（.text段）6.1.5 栈（stack）6.1.6 堆（heap）6.2 内存分配方式6.3 野指针6.4 常见的内存错误及对策6.5 段错误以及调试方法6.5.1 方法一：利用gdb逐步查找段错误6.5.2 方法二：分析core文件6.5.3 方法三：段错误时启动调试6.5.4 方法四：利用backtrace和objdump进行分析6.6 指针与数组的对比第7章 预处理、结构体7.1 宏定义：#define7.1.1 无参宏定义7.1.2 带参宏定义7.2 文件包含7.3 条件编译7.4 宏定义使用技巧7.5 关于#和##7.6 结构体7.6.1 内存字节对齐7.6.2 内存对齐正式原则7.7 #define和typedef的区别7.8 结构体和联合体的区别7.9 浅谈c语言中的位段7.9.1 位段的使用7.9.2 位段结构在内存中的存储方式第8章 函数8.1 函数声明与定义8.1.1 定义8.1.2 声明与定义不同8.2 形式参数和实际参数8.3 参数传递8.3.1 简单变量或数组元素作为函数参数8.3.2 指针变量或数组名作为函数参数8.3.3 数组名作函数参数8.3.4 结构体数组作函数参数8.4 如何编写有多个返回值的c语言函数8.4.1 利用全局变量8.4.2 传递数组指针8.4.3 传递结构体指针8.5 回调函数8.6 变参函数详解：printf的实现8.7 可变参数问题第9章 编码规范9.1 排版9.2 注释9.3 标示符名称第10章 shell编程10.1 什么是shell10.2 几种流行的shell10.3 shell程序设计（基础部分）10.3.1 shell基本语法10.3.2 shell程序的变量和参数10.4 shell程序设计的流程控制10.4.1 test测试命令10.4.2 if条件语句10.4.3 for循环10.4.4 while和until循环10.4.5 case条件选择10.4.6 无条件控制语句break和continue10.4.7 函数定义10.5 命令分组10.6 信号10.7 运行shell程序的方法10.8 bash程序的调试10.9 bash的内部命令第11章 文件操作11.1 linux文件结构11.1.1 linux文件系统11.1.2 linux目录结构11.1.3 linux文件分类11.1.4 常见文件类型11.1.5 linux文件属性11.2 系统调用11.3 linux文件描述符11.4 不带缓存的i／o操作11.4.1 creat函数11.4.2 open函数11.4.3 read函数11.4.4 write函数11.4.5 lseek函数11.4.6 close函数11.4.7 经典范例：文件复制11.5 带缓存的i／o操作11.5.1 三种类型的缓冲11.5.2 fopen函数11.5.3 fclose函数11.5.4 fdopen函数11.5.5 fread函数11.5.6 fwrite函数11.5.7 fseek函数11.5.8 fgetc函数、getc函数和getchar函数11.5.9 fputc函数、putc函数和putchar函数11.6 fgets函数与gets函数比较分析11.7 输出与输入11.7.1 printf函数、fprintf函数和sprintf函数11.7.2 scanf函数、fcanf函数和sscanf函数第12章 进程控制编程12.1 为何需要多进程（或者多线程），为何需要并发12.1.1 进程12.1.2 进程分类12.1.3 进程的属性12.1.4 父进程和子进程12.2 linux进程管理12.2.1 ps监视进程工具12.2.2 pgrep查询进程工具12.2.3 终止进程的工具kill、killall、pkill、xkill12.2.4 top监视系统任务的工具12.2.5 进程的优先级：nice和renice12.3 linux进程的三态12.3.1 三种基本状态12.3.2 三种状态间的转换12.4 linux进程结构12.5 linux进程控制块pcb12.6 linux进程调度12.6.1 调度的目标12.6.2 调度算法12.6.3 优先级反转12.7 进程创建12.7.1 获取进程12.7.2 启动进程：fork（）12.7.3 启动进程：vfork（）12.7.4 启动进程：exec族12.7.5 启动进程：system12.8 进程等待12.8.1 僵尸进程的产生12.8.2 如何避免僵尸进程12.8.3 wait函数和waitpid函数12.9 进程退出12.9.1 退出方式的不同点12.9.2 exit（）和_exit（）函数12.9.3 exit（）和_exit（）的区别第13章 进程间通信方式13.1 进程间通信方式概述13.1.1 进程间通信的目的13.1.2 linux进程间通信方式简介13.2 管道通信13.2.1 建立无名管道13.2.2 读写无名管道13.2.3 无名管道应用实例13.2.4 创建有名管道13.2.5 读写有名管道13.3 管道通信方式的应用场景13.4 信号13.4.1 信号及信号来源13.4.2 信号种类13.4.3 信号处理方式13.4.4 信号发送13.4.5 自定义处理信号方式13.4.6 信号集操作13.4.7 使用信号注意事项13.5 消息队列13.5.1 消息队列基础理论13.5.2 使用消息队列13.5.3 消息队列api13.5.4 消息队列的限制13.5.5 消息队列的应用实例13.6 信号灯13.6.1 信号灯概述13.6.2 内核实现原理13.6.3 使用信号灯13.6.4 信号灯api13.6.5 信号灯的限制13.6.6 竞争问题13.6.7 信号灯应用实例13.7 共享内存方式一13.7.1 内核实现原理13.7.2 mmap（）及其相关系统调用13.7.3 mmap（）范例13.7.4 对mmap（）返回地址的访问13.8 共享内存方式二13.8.1 系统v共享内存原理13.8.2 系统v共享内存api13.8.3 系统v共享内存范例第14章 多线程编程14.1 线程概述14.1.1 为什么有了进程的概念后，还要再引入线程呢14.1.2 多线程的优点14.1.3 多线程的缺点14.2 多线程的实现14.2.1 线程的创建14.2.2 终止线程14.2.3 等待线程终止14.3 线程属性14.3.1 线程属性初始化14.3.2 线程分离14.3.3 线程的继承性14.3.4 线程的调度策略14.3.5 线程的调度参数14.3.6 实例分析14.4 线程同步机制14.4.1 互斥锁mutex14.4.2 互斥锁使用实例14.4.3 条件变量conditions14.4.4 条件变量使用实例第15章 网络编程15.1 tcp／ip协议概述15.1.1 tcp／ip 起源15.1.2 tcp／ip的特性与应用15.1.3 互联网地址15.1.4 域名系统15.1.5 封装15.1.6 tcp／ip工作模型15.1.7 tcp／ip 协议层15.1.8 tcp／ip应用15.1.9 网桥、路由器和网关15.2 tcp和udp15.2.1 tcp协议15.2.2 三次握手协议15.2.3 tcp数据报头15.2.4 udp协议15.2.5 协议的选择15.2.6 ip和端口号15.3 套接字15.3.1 socket概念15.3.2 socket类型15.3.3 socket信息数据结构15.3.4 数据存储优先顺序的转换15.3.5 地址格式转化15.3.6 名字地址转化15.4 网络编程15.4.1 建立socket15.4.2 绑定地址15.4.3 监听15.4.4 接受请求15.4.5 连接服务器15.4.6 发送数据15.4.7 接收数据15.5 采用tcp协议的c／s架构实现15.5.1 模块封装15.5.2 服务器的实现15.5.3 客户端的实现15.6 并发服务器模型15.6.1 多进程解决方案15.6.2 多线程解决方案15.6.3 调用fcntl将sockfd设置为非阻塞模式15.7 多路转接模型15.7.1 服务器的实现15.7.2 客户端的实现15.8 采用udp协议c／s架构的实现15.8.1 服务器的实现15.8.2 客户端的实现15.8.3 udp协议传输文件的实现参考文献
