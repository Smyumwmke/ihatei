计算机科学丛书设计模式:可复用面向对象软件的基础(典藏版)(设计良好.表达清楚的软件设计模式) PDF下载 [美]埃里克·伽玛（ErichGam 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711161833
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711161833
<p>书名:计算机科学丛书设计模式:可复用面向对象软件的基础(典藏版)(设计良好.表达清楚的软件设计模式)</p><p>作者:[美] 埃里克·伽玛（Erich Gam</p><p>页数:290</p><p>定价:¥79.0</p><p>出版社:机械工业出版社</p><p>出版日期:2018-07-01</p><p>ISBN:9787111618331</p><p><h2>本书特色</h2></p>[<p>
本书结合设计实例从面向对象的设计中精选出23个设计模式, 总结了面向对象设计中*有价值的经验, 并且用简洁可复用的形式表达出来。本书分类描述了一组设计良好、 表达清楚的软件设计模式, 这些模式在实用环境下特别有用。 本书适合大学计算机专业的学生、研究生及相关人员参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书结合设计实例从面向对象的设计中精选出23个设计模式, 总结了面向对象设计中*有价值的经验, 并且用简洁可复用的形式表达出来。本书分类描述了一组设计良好、 表达清楚的软件设计模式, 这些模式在实用环境下特别有用。 本书适合大学计算机专业的学生、研究生及相关人员参考。</p>]<p><h2>作者简介</h2></p>[<p>埃里克·伽玛（Erich Gamma）  在瑞士苏黎世大学获得计算机科学博士学位。他与Kent Beck合作开发了单元测试框架JUnit，并领导了Eclipse Java Development Tools项目。他还曾是IBM Rational Jazz项目的主要成员。2011年，Gamma以杰出工程师（Distinguished Engineer）的身份加入微软Visual Studio团队，领导微软位于瑞士苏黎世的实验室。<br/>理查德·赫尔姆（Richard Helm）  在澳大利亚墨尔本大学获得计算机科学博士学位，曾在IBM T. J. Watson担任研究员，并在澳大利亚开创了IBM面向对象技术研究分部。<br/>拉尔夫·约翰逊（Ralph Johnson）  在美国康奈尔大学获得计算机科学博士学位，伊利诺伊大学教授，在模式、重构等领域均有很高造诣。<br/>约翰·威利斯迪斯（John Vlissides）  在美国斯坦福大学获得计算机科学博士学位，是IBM T. J. Watson研究中心的研究员。<br/></p>]<p><h2>目录</h2></p>
    出版者的话赞誉序言前言读者指南第1章引言┊11.1　什么是设计模式┊31.2　Smalltalk MVC中的设计模式┊41.3　描述设计模式┊61.4　设计模式的编目┊71.5　组织编目┊81.6　设计模式怎样解决设计问题┊101.6.1　寻找合适的对象┊101.6.2　决定对象的粒度┊111.6.3　指定对象接口┊111.6.4　描述对象的实现┊121.6.5　运用复用机制┊151.6.6　关联运行时和编译时的结构┊181.6.7　设计应支持变化┊191.7　怎样选择设计模式┊221.8　怎样使用设计模式┊24第2章实例研究：设计一个文档编辑器┊252.1　设计问题┊272.2　文档结构┊272.2.1　递归组合┊282.2.2　图元┊292.2.3　组合模式┊312.3　格式化┊312.3.1　封装格式化算法┊312.3.2　Compositor和Composition┊322.3.3　策略模式┊332.4　修饰用户界面┊342.4.1　透明围栏┊342.4.2　Monoglyph┊352.4.3　Decorator模式┊362.5　支持多种视感标准┊372.5.1　对象创建的抽象┊372.5.2　工厂类和产品类┊382.5.3　Abstract Factory 模式┊402.6　支持多种窗口系统┊402.6.1　是否可以使用Abstract Factory模式┊402.6.2　封装实现依赖关系┊412.6.3　Window和WindowImp┊432.6.4　Bridge模式┊462.7　用户操作┊462.7.1　封装一个请求┊472.7.2　Command类及其子类┊472.7.3　撤销和重做┊482.7.4　命令历史记录┊492.7.5　Command模式┊502.8　拼写检查和断字处理┊502.8.1　访问分散的信息┊512.8.2　封装访问和遍历┊512.8.3　Iterator类及其子类┊522.8.4　Iterator模式┊552.8.5　遍历和遍历过程中的动作┊552.8.6　封装分析┊562.8.7　Visitor类及其子类┊592.8.8　Visitor模式┊602.9　小结┊60第3章创建型模式┊623.1　Abstract Factory（抽象工厂）—对象创建型模式┊663.2　Builder（生成器）—对象创建型模式┊743.3　Factory Method（工厂方法）—对象创建型模式┊813.4　Prototype（原型）—对象创建型模式┊893.5　Singleton（单件）—对象创建型模式┊963.6　创建型模式的讨论┊102第4章结构型模式┊1044.1　Adapter（适配器）—类对象结构型模式┊1064.2　Bridge（桥接）—对象结构型模式┊1154.3　Composite（组合）—对象结构型模式┊1234.4　Decorator（装饰）—对象结构型模式┊1324.5　Facade（外观）—对象结构型模式┊┊1394.6　Flyweight（享元）—对象结构型模式┊1464.7　Proxy（代理）—对象结构型模式┊1554.8　结构型模式的讨论 ┊1644.8.1　Adapter与Bridge┊1644.8.2　Composite、Decorator与Proxy┊164第5章行为型模式┊1665.1　Chain of Responsibility（职责链）—对象行为型模式┊1675.2　Command（命令）—对象行为型模式┊1755.3　Interpreter（解释器）—类行为型模式┊1835.4　Iterator（迭代器）—对象行为型模式┊1935.5　 Mediator（中介者）—对象行为型模式┊2055.6　Memento（备忘录）—对象行为型模式┊2125.7　Observer（观察者）—对象行为型模式┊2195.8　State（状态）—对象行为型模式┊2275.9　Strategy（策略）—对象行为型模式┊2345.10　Template Method（模板方法）—   类行为型模式┊2425.11　Visitor（访问者）—对象行为型   模式┊2465.12　行为型模式的讨论┊2565.12.1　封装变化┊2565.12.2　对象作为参数┊2575.12.3　通信应该被封装还是被分布┊2575.12.4　对发送者和接收者解耦┊2585.12.5　总结┊260第6章结论┊2616.1　设计模式将带来什么┊2626.1.1　一套通用的设计词汇┊2626.1.2　书写文档和学习的辅助手段┊2636.1.3　现有方法的一种补充┊2636.1.4　重构的目标┊2646.2　本书简史┊2656.3　模式界┊2666.3.1　Alexander的模式语言┊2666.3.2　软件中的模式┊2676.4　邀请参与┊2676.5　临别感想┊268附录A词汇表┊269附录B图示符号指南┊273附录 C基本类┊277参考文献┊284
